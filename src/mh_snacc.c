/* -*- c -*- ****************************************************************
 *
 *               Copyright 2003 Samsung Electronics (UK) Ltd.
 *               Copyright 2005,2007 SpongeLava Ltd.
 * 
 *
 *  System        : mhegenc
 *  Module        : mhegenc
 *
 *  Object Name   : $RCSfile$
 *  Revision      : $Revision$
 *  Date          : $Date$
 *  Author        : $Author$
 *  Created By    : Paul Thomas
 *  Create Date   : Mon Jun 9 2003
 *
 *  Description 
 *               SNACC encode/decode routines for mhegenc.
 *  Notes
 *
 *  History
 *
 *   0.9   Oct 2007 Added SetDesktopColour and OrigDesktopColour for
 *                  freesat extensions.
 *      
 ****************************************************************************
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 ****************************************************************************/
/* Note from author. This file WAS generated by snacc 1.3. and then modified
   to work with DER encoding and UK extensions.
   I'm not entirely sure where the copyright stands with this, one assumes that
   a copyright banner would have been included if it was intended, so if anyone
   feels the S.E.R.I. copyright is unjust, please mail mhegenc@seri.co.uk
   with your reasons and, if valid, this copyright banner may be removed by us
   in the future.
*/
/*
 *    mh_snacc.c
 *
 *    "ISO13522-MHEG-5" ASN.1 module encode/decode/print/free C src.
 *
 *    This file was generated by snacc on Wed Jun 19 13:51:19 2002
 *
 *    UBC snacc written by Mike Sample
 *
 *    NOTE: This is a machine generated file - editing not recommended
 */

#include "asn-incl.h"
#include "mh_snacc.h"

static const char *rcsid =
"@(#) $Id$";

AsnInt joint_iso_itu_t = 2;

AsnInt mheg = 19;

AsnInt version = 1;

AsnInt mheg_5 = 17;

/* Stops some annoying warning messages. */
#define BEncAsnIntContent(a,b) BEncAsnIntContent(a, (AsnInt *)(b))
#define BDecAsnIntContent(a,b,c,d,e,f) \
        BDecAsnIntContent(a,b,c,(AsnInt *)(d),e,f)

AsnLen
BEncStandardIdentifierContent PARAMS ((b, v),
BUF_TYPE b _AND_
StandardIdentifier *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncAsnIntContent (b, (&v->mheg));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    itemLen = BEncAsnIntContent (b, (&v->joint_iso_itu));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    return totalLen;

}  /* BEncStandardIdentifierContent */

void
BDecStandardIdentifierContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
StandardIdentifier *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->joint_iso_itu), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -100);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->mheg), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -101);
    }
    else
        longjmp (env, -102);


    if (!seqDone)
        longjmp (env, -103);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecStandardIdentifierContent */




AsnLen
BEncSceneCoordinateSystemContent PARAMS ((b, v),
BUF_TYPE b _AND_
SceneCoordinateSystem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncAsnIntContent (b, (&v->y_scene));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    itemLen = BEncAsnIntContent (b, (&v->x_scene));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    return totalLen;

}  /* BEncSceneCoordinateSystemContent */

void
BDecSceneCoordinateSystemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SceneCoordinateSystem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->x_scene), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -104);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->y_scene), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -105);
    }
    else
        longjmp (env, -106);


    if (!seqDone)
        longjmp (env, -107);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSceneCoordinateSystemContent */




AsnLen
BEncAspectRatioContent PARAMS ((b, v),
BUF_TYPE b _AND_
AspectRatio *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncAsnIntContent (b, (&v->height));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    itemLen = BEncAsnIntContent (b, (&v->width));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    return totalLen;

}  /* BEncAspectRatioContent */

void
BDecAspectRatioContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AspectRatio *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->width), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -108);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->height), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -109);
    }
    else
        longjmp (env, -110);


    if (!seqDone)
        longjmp (env, -111);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAspectRatioContent */




AsnLen
BEncNextSceneContent PARAMS ((b, v),
BUF_TYPE b _AND_
NextScene *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncAsnIntContent (b, (&v->scene_weight));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    itemLen = BEncAsnOctsContent (b, (&v->scene_ref));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 4);

    totalLen += itemLen;

    return totalLen;

}  /* BEncNextSceneContent */

void
BDecNextSceneContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NextScene *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->scene_ref), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -112);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->scene_weight), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -113);
    }
    else
        longjmp (env, -114);


    if (!seqDone)
        longjmp (env, -115);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNextSceneContent */




AsnLen
BEncEventDataContent PARAMS ((b, v),
BUF_TYPE b _AND_
EventData *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case EVENTDATA_OCTETSTRING:
    itemLen = BEncAsnOctsContent (b, (v->a.octetstring));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 4);

    totalLen += itemLen;

    break;

       case EVENTDATA_BOOLEAN:
    itemLen = BEncAsnBoolContent (b, (&v->a.boolean));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 1);

    totalLen += itemLen;

    break;

       case EVENTDATA_INTEGER:
    itemLen = BEncAsnIntContent (b, (&v->a.integer));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncEventDataContent */

void
BDecEventDataContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
EventData *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE):
       case MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE):
        (v->choiceId) = EVENTDATA_OCTETSTRING;
    (v->a.octetstring) = (AsnOcts*) Asn1Alloc (sizeof (AsnOcts));
    CheckAsn1Alloc ((v->a.octetstring), env);
    BDecAsnOctsContent (b, tagId0, elmtLen0, (v->a.octetstring), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE):
        (v->choiceId) = EVENTDATA_BOOLEAN;
    BDecAsnBoolContent (b, tagId0, elmtLen0, (&v->a.boolean), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
        (v->choiceId) = EVENTDATA_INTEGER;
    BDecAsnIntContent (b, tagId0, elmtLen0, (&v->a.integer), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -116);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecEventDataContent */




AsnLen
BEncMovementContent PARAMS ((b, v),
BUF_TYPE b _AND_
Movement *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncAsnIntContent (b, (AsnInt*) component);
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncMovementContent */

void
BDecMovementContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Movement *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        AsnInt **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (AsnInt**) AsnListAppend (v);
    (*tmpVar) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -117);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMovementContent */




AsnLen
BEncOriginalBoxSizeContent PARAMS ((b, v),
BUF_TYPE b _AND_
OriginalBoxSize *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncAsnIntContent (b, (&v->y_length));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    itemLen = BEncAsnIntContent (b, (&v->x_length));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    return totalLen;

}  /* BEncOriginalBoxSizeContent */

void
BDecOriginalBoxSizeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
OriginalBoxSize *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->x_length), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -118);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->y_length), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -119);
    }
    else
        longjmp (env, -120);


    if (!seqDone)
        longjmp (env, -121);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecOriginalBoxSizeContent */




AsnLen
BEncExternalReferenceContent PARAMS ((b, v),
BUF_TYPE b _AND_
ExternalReference *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncAsnIntContent (b, (&v->object_number));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    itemLen = BEncAsnOctsContent (b, (&v->group_identifier));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 4);

    totalLen += itemLen;

    return totalLen;

}  /* BEncExternalReferenceContent */

void
BDecExternalReferenceContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ExternalReference *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->group_identifier), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -122);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->object_number), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -123);
    }
    else
        longjmp (env, -124);


    if (!seqDone)
        longjmp (env, -125);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecExternalReferenceContent */




AsnLen
BEncColourContent PARAMS ((b, v),
BUF_TYPE b _AND_
Colour *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case COLOUR_COLOUR_INDEX:
    itemLen = BEncAsnIntContent (b, (&v->a.colour_index));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    break;

       case COLOUR_ABSOLUTE_COLOUR:
    itemLen = BEncAsnOctsContent (b, (v->a.absolute_colour));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 4);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncColourContent */

void
BDecColourContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Colour *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
        (v->choiceId) = COLOUR_COLOUR_INDEX;
    BDecAsnIntContent (b, tagId0, elmtLen0, (&v->a.colour_index), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE):
       case MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE):
        (v->choiceId) = COLOUR_ABSOLUTE_COLOUR;
    (v->a.absolute_colour) = (AsnOcts*) Asn1Alloc (sizeof (AsnOcts));
    CheckAsn1Alloc ((v->a.absolute_colour), env);
    BDecAsnOctsContent (b, tagId0, elmtLen0, (v->a.absolute_colour), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -126);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecColourContent */




AsnLen
BEncXYPositionContent PARAMS ((b, v),
BUF_TYPE b _AND_
XYPosition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncAsnIntContent (b, (&v->y_position));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    itemLen = BEncAsnIntContent (b, (&v->x_position));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    return totalLen;

}  /* BEncXYPositionContent */

void
BDecXYPositionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
XYPosition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->x_position), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -127);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->y_position), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -128);
    }
    else
        longjmp (env, -129);


    if (!seqDone)
        longjmp (env, -130);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecXYPositionContent */




AsnLen
BEncListGroupClassSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
ListGroupClassSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncListGroupClassSeqOfContent */

void
BDecListGroupClassSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ListGroupClassSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        XYPosition **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (XYPosition**) AsnListAppend (v);
    (*tmpVar) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -131);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecListGroupClassSeqOfContent */




AsnLen
BEncTokenManagerClassSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
TokenManagerClassSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncMovementContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTokenManagerClassSeqOfContent */

void
BDecTokenManagerClassSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TokenManagerClassSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        Movement **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (Movement**) AsnListAppend (v);
    (*tmpVar) = (Movement*) Asn1Alloc (sizeof (Movement));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecMovementContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -132);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTokenManagerClassSeqOfContent */




AsnLen
BEncSceneClassSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
SceneClassSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncNextSceneContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncSceneClassSeqOfContent */

void
BDecSceneClassSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SceneClassSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        NextScene **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (NextScene**) AsnListAppend (v);
    (*tmpVar) = (NextScene*) Asn1Alloc (sizeof (NextScene));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecNextSceneContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -133);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSceneClassSeqOfContent */




AsnLen
BEncReferencedContentContent PARAMS ((b, v),
BUF_TYPE b _AND_
ReferencedContent *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->content_cache_priority)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_cache_priority));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 61);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_size)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_size));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 60);

    totalLen += itemLen;
    }

    itemLen = BEncContentReferenceContent (b, (&v->content_reference));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 4);

    totalLen += itemLen;

    return totalLen;

}  /* BEncReferencedContentContent */

void
BDecReferencedContentContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ReferencedContent *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentReferenceContent (b, tagId1, elmtLen1, (&v->content_reference), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -134);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (CNTX, PRIM, 60))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->content_size) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_size), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_size), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (CNTX, PRIM, 61))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->content_cache_priority) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_cache_priority), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_cache_priority), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -135);
    }


    if (!seqDone)
        longjmp (env, -136);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecReferencedContentContent */




AsnLen
BEncTokenManagerClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
TokenManagerClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->movement_table)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTokenManagerClassSeqOfContent (b, (v->movement_table));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 70);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncTokenManagerClassContent */

void
BDecTokenManagerClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TokenManagerClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (CNTX, CONS, 70):
    (v->movement_table) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->movement_table), env);
    BDecTokenManagerClassSeqOfContent (b, tagId1, elmtLen1, (v->movement_table), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecTokenManagerClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -137);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 0)
    {
        Asn1Error ("BDecTokenManagerClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -138);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTokenManagerClassContent */




AsnLen
BEncInteractibleClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
InteractibleClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->highlight_ref_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->highlight_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 49);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->engine_resp)))
    {
    itemLen = BEncAsnBoolContent (b, (v->engine_resp));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 101);

    totalLen += itemLen;
    }

    return totalLen;

}  /* BEncInteractibleClassContent */

void
BDecInteractibleClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
InteractibleClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (CNTX, PRIM, 101):
    (v->engine_resp) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->engine_resp), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->engine_resp), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 49):
    (v->highlight_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->highlight_ref_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->highlight_ref_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecInteractibleClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -139);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 0)
    {
        Asn1Error ("BDecInteractibleClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -140);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecInteractibleClassContent */




AsnLen
BEncObjectReferenceContent PARAMS ((b, v),
BUF_TYPE b _AND_
ObjectReference *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case OBJECTREFERENCE_EXTERNAL_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncExternalReferenceContent (b, (v->a.external_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;

    break;

       case OBJECTREFERENCE_INTERNAL_REFERENCE:
    itemLen = BEncAsnIntContent (b, (&v->a.internal_reference));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncObjectReferenceContent */

void
BDecObjectReferenceContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ObjectReference *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
        (v->choiceId) = OBJECTREFERENCE_EXTERNAL_REFERENCE;
    (v->a.external_reference) = (ExternalReference*) Asn1Alloc (sizeof (ExternalReference));
    CheckAsn1Alloc ((v->a.external_reference), env);
    BDecExternalReferenceContent (b, tagId0, elmtLen0, (v->a.external_reference), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
        (v->choiceId) = OBJECTREFERENCE_INTERNAL_REFERENCE;
    BDecAsnIntContent (b, tagId0, elmtLen0, (&v->a.internal_reference), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -141);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecObjectReferenceContent */




AsnLen
BEncGenericObjectReferenceContent PARAMS ((b, v),
BUF_TYPE b _AND_
GenericObjectReference *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case GENERICOBJECTREFERENCE_DIRECT_REFERENCE:
    itemLen = BEncObjectReferenceContent (b, (v->a.direct_reference));

    totalLen += itemLen;

    break;

       case GENERICOBJECTREFERENCE_INDIRECT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncIndirectReferenceContent (b, (v->a.indirect_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 236);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncGenericObjectReferenceContent */

void
BDecGenericObjectReferenceContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GenericObjectReference *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
        (v->choiceId) = GENERICOBJECTREFERENCE_DIRECT_REFERENCE;
    (v->a.direct_reference) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->a.direct_reference), env);
    BDecObjectReferenceContent (b, tagId0, elmtLen0, (v->a.direct_reference), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 236):
        (v->choiceId) = GENERICOBJECTREFERENCE_INDIRECT_REFERENCE;
    (v->a.indirect_reference) = (IndirectReference*) Asn1Alloc (sizeof (IndirectReference));
    CheckAsn1Alloc ((v->a.indirect_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecIndirectReferenceContent (b, tagId1, elmtLen1, (v->a.indirect_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -142);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGenericObjectReferenceContent */




AsnLen
BEncGenericContentReferenceContent PARAMS ((b, v),
BUF_TYPE b _AND_
GenericContentReference *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case GENERICCONTENTREFERENCE_CONTENT_REFERENCE:
    itemLen = BEncContentReferenceContent (b, (v->a.content_reference));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, PRIM, 69);

    totalLen += itemLen;

    break;

       case GENERICCONTENTREFERENCE_INDIRECT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncIndirectReferenceContent (b, (v->a.indirect_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 236);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncGenericContentReferenceContent */

void
BDecGenericContentReferenceContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GenericContentReference *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, PRIM, 69):
       case MAKE_TAG_ID (CNTX, CONS, 69):
        (v->choiceId) = GENERICCONTENTREFERENCE_CONTENT_REFERENCE;
    (v->a.content_reference) = (ContentReference*) Asn1Alloc (sizeof (ContentReference));
    CheckAsn1Alloc ((v->a.content_reference), env);
    BDecContentReferenceContent (b, tagId0, elmtLen0, (v->a.content_reference), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 236):
        (v->choiceId) = GENERICCONTENTREFERENCE_INDIRECT_REFERENCE;
    (v->a.indirect_reference) = (IndirectReference*) Asn1Alloc (sizeof (IndirectReference));
    CheckAsn1Alloc ((v->a.indirect_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecIndirectReferenceContent (b, tagId1, elmtLen1, (v->a.indirect_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -143);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGenericContentReferenceContent */




AsnLen
BEncGenericIntegerContent PARAMS ((b, v),
BUF_TYPE b _AND_
GenericInteger *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case GENERICINTEGER_INTEGER:
    itemLen = BEncAsnIntContent (b, (&v->a.integer));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    break;

       case GENERICINTEGER_INDIRECT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncIndirectReferenceContent (b, (v->a.indirect_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 236);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncGenericIntegerContent */

void
BDecGenericIntegerContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GenericInteger *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
        (v->choiceId) = GENERICINTEGER_INTEGER;
    BDecAsnIntContent (b, tagId0, elmtLen0, (&v->a.integer), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 236):
        (v->choiceId) = GENERICINTEGER_INDIRECT_REFERENCE;
    (v->a.indirect_reference) = (IndirectReference*) Asn1Alloc (sizeof (IndirectReference));
    CheckAsn1Alloc ((v->a.indirect_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecIndirectReferenceContent (b, tagId1, elmtLen1, (v->a.indirect_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -144);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGenericIntegerContent */




AsnLen
BEncGenericBooleanContent PARAMS ((b, v),
BUF_TYPE b _AND_
GenericBoolean *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case GENERICBOOLEAN_BOOLEAN:
    itemLen = BEncAsnBoolContent (b, (&v->a.boolean));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 1);

    totalLen += itemLen;

    break;

       case GENERICBOOLEAN_INDIRECT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncIndirectReferenceContent (b, (v->a.indirect_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 236);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncGenericBooleanContent */

void
BDecGenericBooleanContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GenericBoolean *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE):
        (v->choiceId) = GENERICBOOLEAN_BOOLEAN;
    BDecAsnBoolContent (b, tagId0, elmtLen0, (&v->a.boolean), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 236):
        (v->choiceId) = GENERICBOOLEAN_INDIRECT_REFERENCE;
    (v->a.indirect_reference) = (IndirectReference*) Asn1Alloc (sizeof (IndirectReference));
    CheckAsn1Alloc ((v->a.indirect_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecIndirectReferenceContent (b, tagId1, elmtLen1, (v->a.indirect_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -145);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGenericBooleanContent */




AsnLen
BEncGenericOctetStringContent PARAMS ((b, v),
BUF_TYPE b _AND_
GenericOctetString *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case GENERICOCTETSTRING_OCTETSTRING:
    itemLen = BEncAsnOctsContent (b, (v->a.octetstring));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 4);

    totalLen += itemLen;

    break;

       case GENERICOCTETSTRING_INDIRECT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncIndirectReferenceContent (b, (v->a.indirect_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 236);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncGenericOctetStringContent */

void
BDecGenericOctetStringContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GenericOctetString *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE):
       case MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE):
        (v->choiceId) = GENERICOCTETSTRING_OCTETSTRING;
    (v->a.octetstring) = (AsnOcts*) Asn1Alloc (sizeof (AsnOcts));
    CheckAsn1Alloc ((v->a.octetstring), env);
    BDecAsnOctsContent (b, tagId0, elmtLen0, (v->a.octetstring), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 236):
        (v->choiceId) = GENERICOCTETSTRING_INDIRECT_REFERENCE;
    (v->a.indirect_reference) = (IndirectReference*) Asn1Alloc (sizeof (IndirectReference));
    CheckAsn1Alloc ((v->a.indirect_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecIndirectReferenceContent (b, tagId1, elmtLen1, (v->a.indirect_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -146);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGenericOctetStringContent */




AsnLen
BEncStorePersistentSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
StorePersistentSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncObjectReferenceContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncStorePersistentSeqOfContent */

void
BDecStorePersistentSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
StorePersistentSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ObjectReference **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ObjectReference**) AsnListAppend (v);
    (*tmpVar) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecStorePersistentSeqOfContent */




AsnLen
BEncReadPersistentSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
ReadPersistentSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncObjectReferenceContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncReadPersistentSeqOfContent */

void
BDecReadPersistentSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ReadPersistentSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ObjectReference **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ObjectReference**) AsnListAppend (v);
    (*tmpVar) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecReadPersistentSeqOfContent */




AsnLen
BEncFontBodyContent PARAMS ((b, v),
BUF_TYPE b _AND_
FontBody *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case FONTBODY_DIRECT_FONT:
    itemLen = BEncAsnOctsContent (b, (v->a.direct_font));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 4);

    totalLen += itemLen;

    break;

       case FONTBODY_INDIRECT_FONT:
    itemLen = BEncObjectReferenceContent (b, (v->a.indirect_font));

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncFontBodyContent */

void
BDecFontBodyContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
FontBody *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE):
       case MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE):
        (v->choiceId) = FONTBODY_DIRECT_FONT;
    (v->a.direct_font) = (AsnOcts*) Asn1Alloc (sizeof (AsnOcts));
    CheckAsn1Alloc ((v->a.direct_font), env);
    BDecAsnOctsContent (b, tagId0, elmtLen0, (v->a.direct_font), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
        (v->choiceId) = FONTBODY_INDIRECT_FONT;
    (v->a.indirect_font) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->a.indirect_font), env);
    BDecObjectReferenceContent (b, tagId0, elmtLen0, (v->a.indirect_font), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -147);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecFontBodyContent */




AsnLen
BEncContentBodyContent PARAMS ((b, v),
BUF_TYPE b _AND_
ContentBody *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case CONTENTBODY_INCLUDED_CONTENT:
    itemLen = BEncAsnOctsContent (b, (v->a.included_content));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 4);

    totalLen += itemLen;

    break;

       case CONTENTBODY_REFERENCED_CONTENT:
    BEncEocIfNec (b);
    itemLen = BEncReferencedContentContent (b, (v->a.referenced_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncContentBodyContent */

void
BDecContentBodyContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ContentBody *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE):
       case MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE):
        (v->choiceId) = CONTENTBODY_INCLUDED_CONTENT;
    (v->a.included_content) = (AsnOcts*) Asn1Alloc (sizeof (AsnOcts));
    CheckAsn1Alloc ((v->a.included_content), env);
    BDecAsnOctsContent (b, tagId0, elmtLen0, (v->a.included_content), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
        (v->choiceId) = CONTENTBODY_REFERENCED_CONTENT;
    (v->a.referenced_content) = (ReferencedContent*) Asn1Alloc (sizeof (ReferencedContent));
    CheckAsn1Alloc ((v->a.referenced_content), env);
    BDecReferencedContentContent (b, tagId0, elmtLen0, (v->a.referenced_content), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -148);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecContentBodyContent */




AsnLen
BEncLinkConditionContent PARAMS ((b, v),
BUF_TYPE b _AND_
LinkCondition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->event_data)))
    {
    itemLen = BEncEventDataContent (b, (v->event_data));

    totalLen += itemLen;
    }

    itemLen = BEncEventTypeContent (b, (&v->event_type));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 10);

    totalLen += itemLen;

    itemLen = BEncObjectReferenceContent (b, (v->event_source));

    totalLen += itemLen;

    return totalLen;

}  /* BEncLinkConditionContent */

void
BDecLinkConditionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
LinkCondition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->event_source) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->event_source), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->event_source), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -149);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, ENUM_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecEventTypeContent (b, tagId1, elmtLen1, (&v->event_type), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -150);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->event_data) = (EventData*) Asn1Alloc (sizeof (EventData));
    CheckAsn1Alloc ((v->event_data), env);
    BDecEventDataContent (b, tagId1, elmtLen1, (v->event_data), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -151);
    }


    if (!seqDone)
        longjmp (env, -152);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecLinkConditionContent */




AsnLen
BEncProgramClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
ProgramClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->initially_available)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_available));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 65);

    totalLen += itemLen;
    }

    itemLen = BEncAsnOctsContent (b, (&v->name));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, PRIM, 64);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncProgramClassContent */

void
BDecProgramClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ProgramClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 64):
       case MAKE_TAG_ID (CNTX, PRIM, 64):
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->name), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 65):
    (v->initially_available) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_available), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_available), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecProgramClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -153);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecProgramClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -154);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecProgramClassContent */




AsnLen
BEncRemoteProgramClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
RemoteProgramClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->program_connection_tag)))
    {
    itemLen = BEncAsnIntContent (b, (v->program_connection_tag));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 66);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_available)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_available));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 65);

    totalLen += itemLen;
    }

    itemLen = BEncAsnOctsContent (b, (&v->name));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, PRIM, 64);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncRemoteProgramClassContent */

void
BDecRemoteProgramClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
RemoteProgramClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 64):
       case MAKE_TAG_ID (CNTX, PRIM, 64):
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->name), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 65):
    (v->initially_available) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_available), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_available), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 66):
    (v->program_connection_tag) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->program_connection_tag), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->program_connection_tag), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecRemoteProgramClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -155);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecRemoteProgramClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -156);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecRemoteProgramClassContent */




AsnLen
BEncOriginalValueContent PARAMS ((b, v),
BUF_TYPE b _AND_
OriginalValue *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case ORIGINALVALUE_BOOLEAN:
    itemLen = BEncAsnBoolContent (b, (&v->a.boolean));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 1);

    totalLen += itemLen;

    break;

       case ORIGINALVALUE_INTEGER:
    itemLen = BEncAsnIntContent (b, (&v->a.integer));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 2);

    totalLen += itemLen;

    break;

       case ORIGINALVALUE_OCTETSTRING:
    itemLen = BEncAsnOctsContent (b, (v->a.octetstring));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, PRIM, 4);

    totalLen += itemLen;

    break;

       case ORIGINALVALUE_OBJECT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->a.object_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 68);

    totalLen += itemLen;

    break;

       case ORIGINALVALUE_CONTENT_REFERENCE:
    itemLen = BEncContentReferenceContent (b, (v->a.content_reference));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, PRIM, 69);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncOriginalValueContent */

void
BDecOriginalValueContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
OriginalValue *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE):
        (v->choiceId) = ORIGINALVALUE_BOOLEAN;
    BDecAsnBoolContent (b, tagId0, elmtLen0, (&v->a.boolean), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
        (v->choiceId) = ORIGINALVALUE_INTEGER;
    BDecAsnIntContent (b, tagId0, elmtLen0, (&v->a.integer), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE):
       case MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE):
        (v->choiceId) = ORIGINALVALUE_OCTETSTRING;
    (v->a.octetstring) = (AsnOcts*) Asn1Alloc (sizeof (AsnOcts));
    CheckAsn1Alloc ((v->a.octetstring), env);
    BDecAsnOctsContent (b, tagId0, elmtLen0, (v->a.octetstring), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 68):
        (v->choiceId) = ORIGINALVALUE_OBJECT_REFERENCE;
    (v->a.object_reference) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->a.object_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->a.object_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 69):
       case MAKE_TAG_ID (CNTX, CONS, 69):
        (v->choiceId) = ORIGINALVALUE_CONTENT_REFERENCE;
    (v->a.content_reference) = (ContentReference*) Asn1Alloc (sizeof (ContentReference));
    CheckAsn1Alloc ((v->a.content_reference), env);
    BDecContentReferenceContent (b, tagId0, elmtLen0, (v->a.content_reference), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -157);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecOriginalValueContent */




AsnLen
BEncVisibleClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
VisibleClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncVisibleClassContent */

void
BDecVisibleClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
VisibleClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecVisibleClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -158);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecVisibleClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -159);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecVisibleClassContent */




AsnLen
BEncBitmapClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
BitmapClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->original_transparency)))
    {
    itemLen = BEncAsnIntContent (b, (v->original_transparency));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 80);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->tiling)))
    {
    itemLen = BEncAsnBoolContent (b, (v->tiling));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 79);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncBitmapClassContent */

void
BDecBitmapClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
BitmapClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 79):
    (v->tiling) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->tiling), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->tiling), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 80):
    (v->original_transparency) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->original_transparency), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->original_transparency), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecBitmapClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -160);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecBitmapClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -161);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecBitmapClassContent */




AsnLen
BEncLineArtClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
LineArtClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->original_ref_fill_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->original_ref_fill_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 85);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_ref_line_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->original_ref_line_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 84);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_line_style)))
    {
    itemLen = BEncLineArtClassIntContent (b, (v->original_line_style));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 83);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_line_width)))
    {
    itemLen = BEncAsnIntContent (b, (v->original_line_width));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 82);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->bordered_bounding_box)))
    {
    itemLen = BEncAsnBoolContent (b, (v->bordered_bounding_box));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 81);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncLineArtClassContent */

void
BDecLineArtClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
LineArtClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 81):
    (v->bordered_bounding_box) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->bordered_bounding_box), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->bordered_bounding_box), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 82):
    (v->original_line_width) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->original_line_width), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->original_line_width), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 83):
    (v->original_line_style) = (LineArtClassInt*) Asn1Alloc (sizeof (LineArtClassInt));
    CheckAsn1Alloc ((v->original_line_style), env);
    BDecLineArtClassIntContent (b, tagId1, elmtLen1, (v->original_line_style), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 84):
    (v->original_ref_line_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->original_ref_line_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->original_ref_line_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 85):
    (v->original_ref_fill_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->original_ref_fill_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->original_ref_fill_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecLineArtClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -162);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecLineArtClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -163);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecLineArtClassContent */




AsnLen
BEncTextClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
TextClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->text_wrapping)))
    {
    itemLen = BEncAsnBoolContent (b, (v->text_wrapping));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 91);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->start_corner)))
    {
    itemLen = BEncStartCornerContent (b, (v->start_corner));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 90);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->line_orientation)))
    {
    itemLen = BEncLineOrientationContent (b, (v->line_orientation));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 89);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->vertical_justification)))
    {
    itemLen = BEncJustificationContent (b, (v->vertical_justification));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 88);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->horizontal_justification)))
    {
    itemLen = BEncJustificationContent (b, (v->horizontal_justification));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 87);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_font)))
    {
    BEncEocIfNec (b);
    itemLen = BEncFontBodyContent (b, (v->original_font));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 86);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->font_attributes)))
    {
    itemLen = BEncAsnOctsContent (b, (&v->font_attributes));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, PRIM, 43);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->text_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->text_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 41);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->background_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->background_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 39);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->character_set)))
    {
    itemLen = BEncAsnIntContent (b, (v->character_set));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 38);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncTextClassContent */

void
BDecTextClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TextClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 86):
    (v->original_font) = (FontBody*) Asn1Alloc (sizeof (FontBody));
    CheckAsn1Alloc ((v->original_font), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecFontBodyContent (b, tagId2, elmtLen2, (v->original_font), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 43):
       case MAKE_TAG_ID (CNTX, PRIM, 43):
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->font_attributes), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 41):
    (v->text_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->text_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->text_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 39):
    (v->background_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->background_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->background_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 38):
    (v->character_set) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->character_set), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->character_set), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 87):
    (v->horizontal_justification) = (Justification*) Asn1Alloc (sizeof (Justification));
    CheckAsn1Alloc ((v->horizontal_justification), env);
    BDecJustificationContent (b, tagId1, elmtLen1, (v->horizontal_justification), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 88):
    (v->vertical_justification) = (Justification*) Asn1Alloc (sizeof (Justification));
    CheckAsn1Alloc ((v->vertical_justification), env);
    BDecJustificationContent (b, tagId1, elmtLen1, (v->vertical_justification), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 89):
    (v->line_orientation) = (LineOrientation*) Asn1Alloc (sizeof (LineOrientation));
    CheckAsn1Alloc ((v->line_orientation), env);
    BDecLineOrientationContent (b, tagId1, elmtLen1, (v->line_orientation), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 90):
    (v->start_corner) = (StartCorner*) Asn1Alloc (sizeof (StartCorner));
    CheckAsn1Alloc ((v->start_corner), env);
    BDecStartCornerContent (b, tagId1, elmtLen1, (v->start_corner), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 91):
    (v->text_wrapping) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->text_wrapping), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->text_wrapping), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecTextClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -164);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecTextClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -165);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTextClassContent */




AsnLen
BEncAudioClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
AudioClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->original_volume)))
    {
    itemLen = BEncAsnIntContent (b, (v->original_volume));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 99);

    totalLen += itemLen;
    }

    itemLen = BEncAsnIntContent (b, (&v->component_tag));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 98);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncAudioClassContent */

void
BDecAudioClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AudioClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 98):
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->component_tag), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 99):
    (v->original_volume) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->original_volume), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->original_volume), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecAudioClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -166);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecAudioClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -167);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAudioClassContent */




AsnLen
BEncVideoClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
VideoClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->termination)))
    {
    itemLen = BEncTerminationContent (b, (v->termination));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 100);

    totalLen += itemLen;
    }

    itemLen = BEncAsnIntContent (b, (&v->component_tag));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 98);

    totalLen += itemLen;

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncVideoClassContent */

void
BDecVideoClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
VideoClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 98):
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->component_tag), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 100):
    (v->termination) = (Termination*) Asn1Alloc (sizeof (Termination));
    CheckAsn1Alloc ((v->termination), env);
    BDecTerminationContent (b, tagId1, elmtLen1, (v->termination), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecVideoClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -168);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 3)
    {
        Asn1Error ("BDecVideoClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -169);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecVideoClassContent */




AsnLen
BEncRTGraphicsClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
RTGraphicsClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->termination)))
    {
    itemLen = BEncTerminationContent (b, (v->termination));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 100);

    totalLen += itemLen;
    }

    itemLen = BEncAsnIntContent (b, (&v->component_tag));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 98);

    totalLen += itemLen;

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncRTGraphicsClassContent */

void
BDecRTGraphicsClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
RTGraphicsClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 98):
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->component_tag), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 100):
    (v->termination) = (Termination*) Asn1Alloc (sizeof (Termination));
    CheckAsn1Alloc ((v->termination), env);
    BDecTerminationContent (b, tagId1, elmtLen1, (v->termination), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecRTGraphicsClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -170);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 3)
    {
        Asn1Error ("BDecRTGraphicsClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -171);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecRTGraphicsClassContent */




AsnLen
BEncSliderClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
SliderClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->slider_style)))
    {
    itemLen = BEncSliderStyleContent (b, (v->slider_style));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 108);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->step_size)))
    {
    itemLen = BEncAsnIntContent (b, (v->step_size));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 107);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initial_portion)))
    {
    itemLen = BEncAsnIntContent (b, (v->initial_portion));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 106);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initial_value)))
    {
    itemLen = BEncAsnIntContent (b, (v->initial_value));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 105);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->min_value)))
    {
    itemLen = BEncAsnIntContent (b, (v->min_value));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 104);

    totalLen += itemLen;
    }

    itemLen = BEncAsnIntContent (b, (&v->max_value));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 103);

    totalLen += itemLen;

    itemLen = BEncOrientationContent (b, (&v->orientation));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 102);

    totalLen += itemLen;

    if (NOT_NULL ((v->engine_resp)))
    {
    itemLen = BEncAsnBoolContent (b, (v->engine_resp));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 101);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->slider_ref_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->slider_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 50);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->highlight_ref_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->highlight_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 49);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSliderClassContent */

void
BDecSliderClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SliderClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 101):
    (v->engine_resp) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->engine_resp), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->engine_resp), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 49):
    (v->highlight_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->highlight_ref_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->highlight_ref_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 102):
    BDecOrientationContent (b, tagId1, elmtLen1, (&v->orientation), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 103):
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->max_value), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 104):
    (v->min_value) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->min_value), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->min_value), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 105):
    (v->initial_value) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->initial_value), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->initial_value), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 106):
    (v->initial_portion) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->initial_portion), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->initial_portion), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 107):
    (v->step_size) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->step_size), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->step_size), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 108):
    (v->slider_style) = (SliderStyle*) Asn1Alloc (sizeof (SliderStyle));
    CheckAsn1Alloc ((v->slider_style), env);
    BDecSliderStyleContent (b, tagId1, elmtLen1, (v->slider_style), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 50):
    (v->slider_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->slider_ref_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->slider_ref_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecSliderClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -172);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 4)
    {
        Asn1Error ("BDecSliderClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -173);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSliderClassContent */




AsnLen
BEncEntryFieldClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
EntryFieldClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->max_length)))
    {
    itemLen = BEncAsnIntContent (b, (v->max_length));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 112);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->obscured_input)))
    {
    itemLen = BEncAsnBoolContent (b, (v->obscured_input));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 111);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->char_list)))
    {
    itemLen = BEncAsnOctsContent (b, (&v->char_list));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, PRIM, 110);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->input_type)))
    {
    itemLen = BEncInputTypeContent (b, (v->input_type));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 109);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->engine_resp)))
    {
    itemLen = BEncAsnBoolContent (b, (v->engine_resp));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 101);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->text_wrapping)))
    {
    itemLen = BEncAsnBoolContent (b, (v->text_wrapping));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 91);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->start_corner)))
    {
    itemLen = BEncStartCornerContent (b, (v->start_corner));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 90);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->line_orientation)))
    {
    itemLen = BEncLineOrientationContent (b, (v->line_orientation));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 89);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->vertical_justification)))
    {
    itemLen = BEncJustificationContent (b, (v->vertical_justification));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 88);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->horizontal_justification)))
    {
    itemLen = BEncJustificationContent (b, (v->horizontal_justification));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 87);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_font)))
    {
    BEncEocIfNec (b);
    itemLen = BEncFontBodyContent (b, (v->original_font));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 86);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->highlight_ref_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->highlight_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 49);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->font_attributes)))
    {
    itemLen = BEncAsnOctsContent (b, (&v->font_attributes));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, PRIM, 43);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->text_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->text_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 41);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->background_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->background_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 39);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->character_set)))
    {
    itemLen = BEncAsnIntContent (b, (v->character_set));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 38);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncEntryFieldClassContent */

void
BDecEntryFieldClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
EntryFieldClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 86):
    (v->original_font) = (FontBody*) Asn1Alloc (sizeof (FontBody));
    CheckAsn1Alloc ((v->original_font), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecFontBodyContent (b, tagId2, elmtLen2, (v->original_font), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 43):
       case MAKE_TAG_ID (CNTX, PRIM, 43):
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->font_attributes), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 41):
    (v->text_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->text_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->text_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 39):
    (v->background_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->background_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->background_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 38):
    (v->character_set) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->character_set), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->character_set), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 87):
    (v->horizontal_justification) = (Justification*) Asn1Alloc (sizeof (Justification));
    CheckAsn1Alloc ((v->horizontal_justification), env);
    BDecJustificationContent (b, tagId1, elmtLen1, (v->horizontal_justification), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 88):
    (v->vertical_justification) = (Justification*) Asn1Alloc (sizeof (Justification));
    CheckAsn1Alloc ((v->vertical_justification), env);
    BDecJustificationContent (b, tagId1, elmtLen1, (v->vertical_justification), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 89):
    (v->line_orientation) = (LineOrientation*) Asn1Alloc (sizeof (LineOrientation));
    CheckAsn1Alloc ((v->line_orientation), env);
    BDecLineOrientationContent (b, tagId1, elmtLen1, (v->line_orientation), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 90):
    (v->start_corner) = (StartCorner*) Asn1Alloc (sizeof (StartCorner));
    CheckAsn1Alloc ((v->start_corner), env);
    BDecStartCornerContent (b, tagId1, elmtLen1, (v->start_corner), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 91):
    (v->text_wrapping) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->text_wrapping), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->text_wrapping), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 101):
    (v->engine_resp) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->engine_resp), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->engine_resp), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 49):
    (v->highlight_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->highlight_ref_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->highlight_ref_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 109):
    (v->input_type) = (InputType*) Asn1Alloc (sizeof (InputType));
    CheckAsn1Alloc ((v->input_type), env);
    BDecInputTypeContent (b, tagId1, elmtLen1, (v->input_type), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 110):
       case MAKE_TAG_ID (CNTX, PRIM, 110):
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->char_list), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 111):
    (v->obscured_input) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->obscured_input), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->obscured_input), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 112):
    (v->max_length) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->max_length), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->max_length), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecEntryFieldClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -174);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecEntryFieldClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -175);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecEntryFieldClassContent */




AsnLen
BEncHyperTextClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
HyperTextClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->engine_resp)))
    {
    itemLen = BEncAsnBoolContent (b, (v->engine_resp));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 101);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->text_wrapping)))
    {
    itemLen = BEncAsnBoolContent (b, (v->text_wrapping));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 91);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->start_corner)))
    {
    itemLen = BEncStartCornerContent (b, (v->start_corner));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 90);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->line_orientation)))
    {
    itemLen = BEncLineOrientationContent (b, (v->line_orientation));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 89);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->vertical_justification)))
    {
    itemLen = BEncJustificationContent (b, (v->vertical_justification));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 88);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->horizontal_justification)))
    {
    itemLen = BEncJustificationContent (b, (v->horizontal_justification));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 87);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_font)))
    {
    BEncEocIfNec (b);
    itemLen = BEncFontBodyContent (b, (v->original_font));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 86);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->highlight_ref_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->highlight_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 49);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->font_attributes)))
    {
    itemLen = BEncAsnOctsContent (b, (&v->font_attributes));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, PRIM, 43);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->text_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->text_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 41);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->background_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->background_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 39);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->character_set)))
    {
    itemLen = BEncAsnIntContent (b, (v->character_set));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 38);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncHyperTextClassContent */

void
BDecHyperTextClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
HyperTextClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 86):
    (v->original_font) = (FontBody*) Asn1Alloc (sizeof (FontBody));
    CheckAsn1Alloc ((v->original_font), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecFontBodyContent (b, tagId2, elmtLen2, (v->original_font), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 43):
       case MAKE_TAG_ID (CNTX, PRIM, 43):
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->font_attributes), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 41):
    (v->text_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->text_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->text_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 39):
    (v->background_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->background_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->background_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 38):
    (v->character_set) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->character_set), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->character_set), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 87):
    (v->horizontal_justification) = (Justification*) Asn1Alloc (sizeof (Justification));
    CheckAsn1Alloc ((v->horizontal_justification), env);
    BDecJustificationContent (b, tagId1, elmtLen1, (v->horizontal_justification), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 88):
    (v->vertical_justification) = (Justification*) Asn1Alloc (sizeof (Justification));
    CheckAsn1Alloc ((v->vertical_justification), env);
    BDecJustificationContent (b, tagId1, elmtLen1, (v->vertical_justification), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 89):
    (v->line_orientation) = (LineOrientation*) Asn1Alloc (sizeof (LineOrientation));
    CheckAsn1Alloc ((v->line_orientation), env);
    BDecLineOrientationContent (b, tagId1, elmtLen1, (v->line_orientation), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 90):
    (v->start_corner) = (StartCorner*) Asn1Alloc (sizeof (StartCorner));
    CheckAsn1Alloc ((v->start_corner), env);
    BDecStartCornerContent (b, tagId1, elmtLen1, (v->start_corner), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 91):
    (v->text_wrapping) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->text_wrapping), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->text_wrapping), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 101):
    (v->engine_resp) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->engine_resp), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->engine_resp), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 49):
    (v->highlight_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->highlight_ref_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->highlight_ref_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecHyperTextClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -176);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecHyperTextClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -177);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecHyperTextClassContent */




AsnLen
BEncButtonClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
ButtonClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->engine_resp)))
    {
    itemLen = BEncAsnBoolContent (b, (v->engine_resp));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 101);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->highlight_ref_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->highlight_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 49);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->button_ref_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->button_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 48);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncButtonClassContent */

void
BDecButtonClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ButtonClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 101):
    (v->engine_resp) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->engine_resp), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->engine_resp), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 49):
    (v->highlight_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->highlight_ref_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->highlight_ref_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 48):
    (v->button_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->button_ref_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->button_ref_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecButtonClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -178);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecButtonClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -179);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecButtonClassContent */




AsnLen
BEncPushButtonClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
PushButtonClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (ASNOCTS_PRESENT ((&v->original_label)))
    {
    itemLen = BEncAsnOctsContent (b, (&v->original_label));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, PRIM, 113);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->engine_resp)))
    {
    itemLen = BEncAsnBoolContent (b, (v->engine_resp));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 101);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->highlight_ref_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->highlight_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 49);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->button_ref_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->button_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 48);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->character_set)))
    {
    itemLen = BEncAsnIntContent (b, (v->character_set));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 38);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncPushButtonClassContent */

void
BDecPushButtonClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
PushButtonClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 101):
    (v->engine_resp) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->engine_resp), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->engine_resp), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 49):
    (v->highlight_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->highlight_ref_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->highlight_ref_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 48):
    (v->button_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->button_ref_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->button_ref_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 113):
       case MAKE_TAG_ID (CNTX, PRIM, 113):
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->original_label), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 38):
    (v->character_set) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->character_set), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->character_set), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecPushButtonClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -180);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecPushButtonClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -181);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecPushButtonClassContent */




AsnLen
BEncSwitchButtonClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
SwitchButtonClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncButtonStyleContent (b, (&v->button_style));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 114);

    totalLen += itemLen;

    if (ASNOCTS_PRESENT ((&v->original_label)))
    {
    itemLen = BEncAsnOctsContent (b, (&v->original_label));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, PRIM, 113);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->engine_resp)))
    {
    itemLen = BEncAsnBoolContent (b, (v->engine_resp));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 101);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_palette_ref)))
    {
    BEncEocIfNec (b);
    itemLen = BEncObjectReferenceContent (b, (v->original_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 78);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_position)))
    {
    BEncEocIfNec (b);
    itemLen = BEncXYPositionContent (b, (v->original_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 77);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncOriginalBoxSizeContent (b, (v->original_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 76);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->highlight_ref_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->highlight_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 49);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->button_ref_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->button_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 48);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->character_set)))
    {
    itemLen = BEncAsnIntContent (b, (v->character_set));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 38);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSwitchButtonClassContent */

void
BDecSwitchButtonClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SwitchButtonClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 76):
    (v->original_box_size) = (OriginalBoxSize*) Asn1Alloc (sizeof (OriginalBoxSize));
    CheckAsn1Alloc ((v->original_box_size), env);
    BDecOriginalBoxSizeContent (b, tagId1, elmtLen1, (v->original_box_size), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 77):
    (v->original_position) = (XYPosition*) Asn1Alloc (sizeof (XYPosition));
    CheckAsn1Alloc ((v->original_position), env);
    BDecXYPositionContent (b, tagId1, elmtLen1, (v->original_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 78):
    (v->original_palette_ref) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->original_palette_ref), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecObjectReferenceContent (b, tagId2, elmtLen2, (v->original_palette_ref), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 101):
    (v->engine_resp) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->engine_resp), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->engine_resp), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 49):
    (v->highlight_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->highlight_ref_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->highlight_ref_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 48):
    (v->button_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->button_ref_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->button_ref_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 113):
       case MAKE_TAG_ID (CNTX, PRIM, 113):
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->original_label), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 38):
    (v->character_set) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->character_set), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->character_set), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 114):
    BDecButtonStyleContent (b, tagId1, elmtLen1, (&v->button_style), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

    default:
        Asn1Error ("BDecSwitchButtonClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -182);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 3)
    {
        Asn1Error ("BDecSwitchButtonClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -183);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSwitchButtonClassContent */




AsnLen
BEncAddContent PARAMS ((b, v),
BUF_TYPE b _AND_
Add *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->value));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncAddContent */

void
BDecAddContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Add *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -184);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->value) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->value), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->value), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -185);
    }
    else
        longjmp (env, -186);


    if (!seqDone)
        longjmp (env, -187);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAddContent */




AsnLen
BEncAddItemContent PARAMS ((b, v),
BUF_TYPE b _AND_
AddItem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericObjectReferenceContent (b, (v->visible_reference));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->item_index));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncAddItemContent */

void
BDecAddItemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
AddItem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -188);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->item_index) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->item_index), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->item_index), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -189);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->visible_reference) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->visible_reference), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->visible_reference), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -190);
    }
    else
        longjmp (env, -191);


    if (!seqDone)
        longjmp (env, -192);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAddItemContent */




AsnLen
BEncAppendContent PARAMS ((b, v),
BUF_TYPE b _AND_
Append *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericOctetStringContent (b, (v->append_value));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncAppendContent */

void
BDecAppendContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Append *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -193);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->append_value) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->append_value), env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->append_value), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -194);
    }
    else
        longjmp (env, -195);


    if (!seqDone)
        longjmp (env, -196);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecAppendContent */




AsnLen
BEncCallActionSlotContent PARAMS ((b, v),
BUF_TYPE b _AND_
CallActionSlot *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->index));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncCallActionSlotContent */

void
BDecCallActionSlotContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
CallActionSlot *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -197);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->index) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->index), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->index), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -198);
    }
    else
        longjmp (env, -199);


    if (!seqDone)
        longjmp (env, -200);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCallActionSlotContent */




AsnLen
BEncCloneContent PARAMS ((b, v),
BUF_TYPE b _AND_
Clone *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->clone_ref_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncCloneContent */

void
BDecCloneContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Clone *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -201);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->clone_ref_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->clone_ref_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->clone_ref_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -202);
    }
    else
        longjmp (env, -203);


    if (!seqDone)
        longjmp (env, -204);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCloneContent */




AsnLen
BEncCloseConnectionContent PARAMS ((b, v),
BUF_TYPE b _AND_
CloseConnection *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->connection_tag));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncCloseConnectionContent */

void
BDecCloseConnectionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
CloseConnection *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -205);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->connection_tag) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->connection_tag), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->connection_tag), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -206);
    }
    else
        longjmp (env, -207);


    if (!seqDone)
        longjmp (env, -208);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCloseConnectionContent */




AsnLen
BEncDelItemContent PARAMS ((b, v),
BUF_TYPE b _AND_
DelItem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericObjectReferenceContent (b, (v->visible_reference));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncDelItemContent */

void
BDecDelItemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DelItem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -209);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->visible_reference) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->visible_reference), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->visible_reference), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -210);
    }
    else
        longjmp (env, -211);


    if (!seqDone)
        longjmp (env, -212);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDelItemContent */




AsnLen
BEncDeselectItemContent PARAMS ((b, v),
BUF_TYPE b _AND_
DeselectItem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->item_index));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncDeselectItemContent */

void
BDecDeselectItemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DeselectItem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -213);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->item_index) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->item_index), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->item_index), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -214);
    }
    else
        longjmp (env, -215);


    if (!seqDone)
        longjmp (env, -216);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDeselectItemContent */




AsnLen
BEncDivideContent PARAMS ((b, v),
BUF_TYPE b _AND_
Divide *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->value));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncDivideContent */

void
BDecDivideContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Divide *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -217);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->value) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->value), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->value), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -218);
    }
    else
        longjmp (env, -219);


    if (!seqDone)
        longjmp (env, -220);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDivideContent */




AsnLen
BEncDrawArcContent PARAMS ((b, v),
BUF_TYPE b _AND_
DrawArc *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->arc_angle));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->start_angle));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->ellipse_height));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->ellipse_width));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->y));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncDrawArcContent */

void
BDecDrawArcContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DrawArc *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -221);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -222);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -223);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->ellipse_width) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->ellipse_width), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->ellipse_width), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -224);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->ellipse_height) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->ellipse_height), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->ellipse_height), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -225);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->start_angle) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->start_angle), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->start_angle), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -226);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->arc_angle) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->arc_angle), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->arc_angle), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -227);
    }
    else
        longjmp (env, -228);


    if (!seqDone)
        longjmp (env, -229);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDrawArcContent */




AsnLen
BEncDrawLineContent PARAMS ((b, v),
BUF_TYPE b _AND_
DrawLine *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->y2));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x2));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->y1));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x1));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncDrawLineContent */

void
BDecDrawLineContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DrawLine *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -230);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x1) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x1), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x1), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -231);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y1) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y1), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y1), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -232);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x2) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x2), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x2), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -233);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y2) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y2), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y2), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -234);
    }
    else
        longjmp (env, -235);


    if (!seqDone)
        longjmp (env, -236);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDrawLineContent */




AsnLen
BEncDrawOvalContent PARAMS ((b, v),
BUF_TYPE b _AND_
DrawOval *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->ellipse_height));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->ellipse_width));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->y));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncDrawOvalContent */

void
BDecDrawOvalContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DrawOval *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -237);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -238);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -239);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->ellipse_width) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->ellipse_width), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->ellipse_width), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -240);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->ellipse_height) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->ellipse_height), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->ellipse_height), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -241);
    }
    else
        longjmp (env, -242);


    if (!seqDone)
        longjmp (env, -243);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDrawOvalContent */




AsnLen
BEncDrawRectangleContent PARAMS ((b, v),
BUF_TYPE b _AND_
DrawRectangle *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->y2));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x2));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->y1));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x1));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncDrawRectangleContent */

void
BDecDrawRectangleContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DrawRectangle *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -244);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x1) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x1), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x1), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -245);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y1) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y1), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y1), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -246);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x2) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x2), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x2), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -247);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y2) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y2), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y2), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -248);
    }
    else
        longjmp (env, -249);


    if (!seqDone)
        longjmp (env, -250);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDrawRectangleContent */




AsnLen
BEncDrawSectorContent PARAMS ((b, v),
BUF_TYPE b _AND_
DrawSector *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->arc_angle));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->start_angle));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->ellipse_height));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->ellipse_width));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->y));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncDrawSectorContent */

void
BDecDrawSectorContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DrawSector *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -251);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -252);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -253);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->ellipse_width) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->ellipse_width), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->ellipse_width), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -254);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->ellipse_height) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->ellipse_height), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->ellipse_height), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -255);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->start_angle) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->start_angle), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->start_angle), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -256);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->arc_angle) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->arc_angle), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->arc_angle), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -257);
    }
    else
        longjmp (env, -258);


    if (!seqDone)
        longjmp (env, -259);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDrawSectorContent */




AsnLen
BEncGetAvailabilityStatusContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetAvailabilityStatus *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->availability_status_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetAvailabilityStatusContent */

void
BDecGetAvailabilityStatusContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetAvailabilityStatus *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -260);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->availability_status_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->availability_status_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->availability_status_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -261);
    }
    else
        longjmp (env, -262);


    if (!seqDone)
        longjmp (env, -263);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetAvailabilityStatusContent */




AsnLen
BEncGetBoxSizeContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetBoxSize *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->y_box_size_var));

    totalLen += itemLen;

    itemLen = BEncObjectReferenceContent (b, (v->x_box_size_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetBoxSizeContent */

void
BDecGetBoxSizeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetBoxSize *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -264);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x_box_size_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->x_box_size_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->x_box_size_var), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -265);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y_box_size_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->y_box_size_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->y_box_size_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -266);
    }
    else
        longjmp (env, -267);


    if (!seqDone)
        longjmp (env, -268);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetBoxSizeContent */




AsnLen
BEncGetCellItemContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetCellItem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->item_ref_var));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->cell_index));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetCellItemContent */

void
BDecGetCellItemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetCellItem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -269);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->cell_index) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->cell_index), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->cell_index), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -270);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->item_ref_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->item_ref_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->item_ref_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -271);
    }
    else
        longjmp (env, -272);


    if (!seqDone)
        longjmp (env, -273);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetCellItemContent */




AsnLen
BEncGetCursorPositionContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetCursorPosition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->y_out));

    totalLen += itemLen;

    itemLen = BEncObjectReferenceContent (b, (v->x_out));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetCursorPositionContent */

void
BDecGetCursorPositionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetCursorPosition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -274);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x_out) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->x_out), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->x_out), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -275);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y_out) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->y_out), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->y_out), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -276);
    }
    else
        longjmp (env, -277);


    if (!seqDone)
        longjmp (env, -278);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetCursorPositionContent */




AsnLen
BEncGetEngineSupportContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetEngineSupport *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->answer));

    totalLen += itemLen;

    itemLen = BEncGenericOctetStringContent (b, (v->feature));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetEngineSupportContent */

void
BDecGetEngineSupportContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetEngineSupport *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -279);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->feature) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->feature), env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->feature), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -280);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->answer) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->answer), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->answer), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -281);
    }
    else
        longjmp (env, -282);


    if (!seqDone)
        longjmp (env, -283);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetEngineSupportContent */




AsnLen
BEncGetEntryPointContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetEntryPoint *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->entry_point_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetEntryPointContent */

void
BDecGetEntryPointContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetEntryPoint *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -284);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->entry_point_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->entry_point_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->entry_point_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -285);
    }
    else
        longjmp (env, -286);


    if (!seqDone)
        longjmp (env, -287);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetEntryPointContent */




AsnLen
BEncGetFillColourContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetFillColour *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->fill_colour_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetFillColourContent */

void
BDecGetFillColourContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetFillColour *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -288);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->fill_colour_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->fill_colour_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->fill_colour_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -289);
    }
    else
        longjmp (env, -290);


    if (!seqDone)
        longjmp (env, -291);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetFillColourContent */




AsnLen
BEncGetFirstItemContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetFirstItem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->first_item_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetFirstItemContent */

void
BDecGetFirstItemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetFirstItem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -292);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->first_item_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->first_item_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->first_item_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -293);
    }
    else
        longjmp (env, -294);


    if (!seqDone)
        longjmp (env, -295);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetFirstItemContent */




AsnLen
BEncGetHighlightStatusContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetHighlightStatus *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->highlight_status_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetHighlightStatusContent */

void
BDecGetHighlightStatusContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetHighlightStatus *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -296);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->highlight_status_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->highlight_status_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->highlight_status_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -297);
    }
    else
        longjmp (env, -298);


    if (!seqDone)
        longjmp (env, -299);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetHighlightStatusContent */




AsnLen
BEncGetInteractionStatusContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetInteractionStatus *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->interaction_status_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetInteractionStatusContent */

void
BDecGetInteractionStatusContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetInteractionStatus *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -300);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->interaction_status_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->interaction_status_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->interaction_status_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -301);
    }
    else
        longjmp (env, -302);


    if (!seqDone)
        longjmp (env, -303);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetInteractionStatusContent */




AsnLen
BEncGetItemStatusContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetItemStatus *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->item_status_var));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->item_index));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetItemStatusContent */

void
BDecGetItemStatusContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetItemStatus *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -304);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->item_index) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->item_index), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->item_index), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -305);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->item_status_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->item_status_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->item_status_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -306);
    }
    else
        longjmp (env, -307);


    if (!seqDone)
        longjmp (env, -308);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetItemStatusContent */




AsnLen
BEncGetLabelContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetLabel *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->label_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetLabelContent */

void
BDecGetLabelContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetLabel *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -309);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->label_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->label_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->label_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -310);
    }
    else
        longjmp (env, -311);


    if (!seqDone)
        longjmp (env, -312);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetLabelContent */




AsnLen
BEncGetLastAnchorFiredContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetLastAnchorFired *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->last_anchor_fired_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetLastAnchorFiredContent */

void
BDecGetLastAnchorFiredContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetLastAnchorFired *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -313);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->last_anchor_fired_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->last_anchor_fired_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->last_anchor_fired_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -314);
    }
    else
        longjmp (env, -315);


    if (!seqDone)
        longjmp (env, -316);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetLastAnchorFiredContent */




AsnLen
BEncGetLineColourContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetLineColour *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->line_colour_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetLineColourContent */

void
BDecGetLineColourContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetLineColour *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -317);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->line_colour_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->line_colour_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->line_colour_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -318);
    }
    else
        longjmp (env, -319);


    if (!seqDone)
        longjmp (env, -320);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetLineColourContent */




AsnLen
BEncGetLineStyleContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetLineStyle *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->line_style_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetLineStyleContent */

void
BDecGetLineStyleContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetLineStyle *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -321);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->line_style_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->line_style_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->line_style_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -322);
    }
    else
        longjmp (env, -323);


    if (!seqDone)
        longjmp (env, -324);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetLineStyleContent */




AsnLen
BEncGetLineWidthContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetLineWidth *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->line_width_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetLineWidthContent */

void
BDecGetLineWidthContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetLineWidth *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -325);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->line_width_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->line_width_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->line_width_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -326);
    }
    else
        longjmp (env, -327);


    if (!seqDone)
        longjmp (env, -328);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetLineWidthContent */




AsnLen
BEncGetListItemContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetListItem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->item_ref_var));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->item_index));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetListItemContent */

void
BDecGetListItemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetListItem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -329);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->item_index) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->item_index), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->item_index), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -330);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->item_ref_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->item_ref_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->item_ref_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -331);
    }
    else
        longjmp (env, -332);


    if (!seqDone)
        longjmp (env, -333);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetListItemContent */




AsnLen
BEncGetListSizeContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetListSize *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->size_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetListSizeContent */

void
BDecGetListSizeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetListSize *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -334);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->size_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->size_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->size_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -335);
    }
    else
        longjmp (env, -336);


    if (!seqDone)
        longjmp (env, -337);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetListSizeContent */




AsnLen
BEncGetOverwriteModeContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetOverwriteMode *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->overwrite_mode_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetOverwriteModeContent */

void
BDecGetOverwriteModeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetOverwriteMode *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -338);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->overwrite_mode_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->overwrite_mode_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->overwrite_mode_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -339);
    }
    else
        longjmp (env, -340);


    if (!seqDone)
        longjmp (env, -341);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetOverwriteModeContent */




AsnLen
BEncGetPortionContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetPortion *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->portion_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetPortionContent */

void
BDecGetPortionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetPortion *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -342);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->portion_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->portion_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->portion_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -343);
    }
    else
        longjmp (env, -344);


    if (!seqDone)
        longjmp (env, -345);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetPortionContent */




AsnLen
BEncGetPositionContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetPosition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->y_position_var));

    totalLen += itemLen;

    itemLen = BEncObjectReferenceContent (b, (v->x_position_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetPositionContent */

void
BDecGetPositionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetPosition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -346);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x_position_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->x_position_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->x_position_var), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -347);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y_position_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->y_position_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->y_position_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -348);
    }
    else
        longjmp (env, -349);


    if (!seqDone)
        longjmp (env, -350);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetPositionContent */




AsnLen
BEncGetRunningStatusContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetRunningStatus *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->running_status_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetRunningStatusContent */

void
BDecGetRunningStatusContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetRunningStatus *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -351);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->running_status_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->running_status_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->running_status_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -352);
    }
    else
        longjmp (env, -353);


    if (!seqDone)
        longjmp (env, -354);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetRunningStatusContent */




AsnLen
BEncGetSelectionStatusContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetSelectionStatus *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->selection_status_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetSelectionStatusContent */

void
BDecGetSelectionStatusContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetSelectionStatus *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -355);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->selection_status_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->selection_status_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->selection_status_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -356);
    }
    else
        longjmp (env, -357);


    if (!seqDone)
        longjmp (env, -358);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetSelectionStatusContent */




AsnLen
BEncGetSliderValueContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetSliderValue *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->slider_value_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetSliderValueContent */

void
BDecGetSliderValueContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetSliderValue *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -359);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->slider_value_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->slider_value_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->slider_value_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -360);
    }
    else
        longjmp (env, -361);


    if (!seqDone)
        longjmp (env, -362);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetSliderValueContent */




AsnLen
BEncGetTextContentContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetTextContent *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->text_content_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetTextContentContent */

void
BDecGetTextContentContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetTextContent *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -363);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->text_content_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->text_content_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->text_content_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -364);
    }
    else
        longjmp (env, -365);


    if (!seqDone)
        longjmp (env, -366);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetTextContentContent */




AsnLen
BEncGetTextDataContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetTextData *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->text_data_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetTextDataContent */

void
BDecGetTextDataContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetTextData *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -367);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->text_data_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->text_data_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->text_data_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -368);
    }
    else
        longjmp (env, -369);


    if (!seqDone)
        longjmp (env, -370);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetTextDataContent */




AsnLen
BEncGetTokenPositionContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetTokenPosition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->token_position_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetTokenPositionContent */

void
BDecGetTokenPositionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetTokenPosition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -371);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->token_position_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->token_position_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->token_position_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -372);
    }
    else
        longjmp (env, -373);


    if (!seqDone)
        longjmp (env, -374);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetTokenPositionContent */




AsnLen
BEncGetVolumeContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetVolume *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->volume_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetVolumeContent */

void
BDecGetVolumeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetVolume *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -375);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->volume_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->volume_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->volume_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -376);
    }
    else
        longjmp (env, -377);


    if (!seqDone)
        longjmp (env, -378);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetVolumeContent */




AsnLen
BEncModuloContent PARAMS ((b, v),
BUF_TYPE b _AND_
Modulo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->value));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncModuloContent */

void
BDecModuloContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Modulo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -379);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->value) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->value), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->value), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -380);
    }
    else
        longjmp (env, -381);


    if (!seqDone)
        longjmp (env, -382);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecModuloContent */




AsnLen
BEncMoveContent PARAMS ((b, v),
BUF_TYPE b _AND_
Move *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->movement_identifier));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncMoveContent */

void
BDecMoveContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Move *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -383);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->movement_identifier) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->movement_identifier), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->movement_identifier), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -384);
    }
    else
        longjmp (env, -385);


    if (!seqDone)
        longjmp (env, -386);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMoveContent */




AsnLen
BEncMoveToContent PARAMS ((b, v),
BUF_TYPE b _AND_
MoveTo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->index));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncMoveToContent */

void
BDecMoveToContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
MoveTo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -387);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->index) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->index), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->index), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -388);
    }
    else
        longjmp (env, -389);


    if (!seqDone)
        longjmp (env, -390);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMoveToContent */




AsnLen
BEncMultiplyContent PARAMS ((b, v),
BUF_TYPE b _AND_
Multiply *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->value));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncMultiplyContent */

void
BDecMultiplyContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Multiply *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -391);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->value) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->value), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->value), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -392);
    }
    else
        longjmp (env, -393);


    if (!seqDone)
        longjmp (env, -394);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecMultiplyContent */




AsnLen
BEncOpenConnectionContent PARAMS ((b, v),
BUF_TYPE b _AND_
OpenConnection *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->connection_tag));

    totalLen += itemLen;

    itemLen = BEncGenericOctetStringContent (b, (v->address));

    totalLen += itemLen;

    itemLen = BEncGenericOctetStringContent (b, (v->protocol));

    totalLen += itemLen;

    itemLen = BEncObjectReferenceContent (b, (v->open_succeeded));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncOpenConnectionContent */

void
BDecOpenConnectionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
OpenConnection *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -395);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->open_succeeded) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->open_succeeded), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->open_succeeded), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -396);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->protocol) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->protocol), env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->protocol), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -397);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->address) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->address), env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->address), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -398);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->connection_tag) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->connection_tag), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->connection_tag), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -399);
    }
    else
        longjmp (env, -400);


    if (!seqDone)
        longjmp (env, -401);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecOpenConnectionContent */




AsnLen
BEncPutBeforeContent PARAMS ((b, v),
BUF_TYPE b _AND_
PutBefore *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericObjectReferenceContent (b, (v->reference_visible));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncPutBeforeContent */

void
BDecPutBeforeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
PutBefore *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -402);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->reference_visible) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->reference_visible), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->reference_visible), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -403);
    }
    else
        longjmp (env, -404);


    if (!seqDone)
        longjmp (env, -405);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecPutBeforeContent */




AsnLen
BEncPutBehindContent PARAMS ((b, v),
BUF_TYPE b _AND_
PutBehind *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericObjectReferenceContent (b, (v->reference_visible));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncPutBehindContent */

void
BDecPutBehindContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
PutBehind *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -406);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->reference_visible) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->reference_visible), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->reference_visible), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -407);
    }
    else
        longjmp (env, -408);


    if (!seqDone)
        longjmp (env, -409);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecPutBehindContent */




AsnLen
BEncReadPersistentContent PARAMS ((b, v),
BUF_TYPE b _AND_
ReadPersistent *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericOctetStringContent (b, (v->in_file_name));

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncReadPersistentSeqOfContent (b, (v->out_variables));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;

    itemLen = BEncObjectReferenceContent (b, (v->read_succeeded));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncReadPersistentContent */

void
BDecReadPersistentContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ReadPersistent *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -410);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->read_succeeded) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->read_succeeded), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->read_succeeded), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -411);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->out_variables) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->out_variables), env);
    BDecReadPersistentSeqOfContent (b, tagId1, elmtLen1, (v->out_variables), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -412);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->in_file_name) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->in_file_name), env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->in_file_name), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -413);
    }
    else
        longjmp (env, -414);


    if (!seqDone)
        longjmp (env, -415);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecReadPersistentContent */




AsnLen
BEncScaleBitmapContent PARAMS ((b, v),
BUF_TYPE b _AND_
ScaleBitmap *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->y_scale));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x_scale));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncScaleBitmapContent */

void
BDecScaleBitmapContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ScaleBitmap *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -416);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x_scale) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x_scale), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x_scale), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -417);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y_scale) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y_scale), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y_scale), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -418);
    }
    else
        longjmp (env, -419);


    if (!seqDone)
        longjmp (env, -420);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecScaleBitmapContent */




AsnLen
BEncScaleVideoContent PARAMS ((b, v),
BUF_TYPE b _AND_
ScaleVideo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->y_scale));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x_scale));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncScaleVideoContent */

void
BDecScaleVideoContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ScaleVideo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -421);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x_scale) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x_scale), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x_scale), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -422);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y_scale) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y_scale), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y_scale), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -423);
    }
    else
        longjmp (env, -424);


    if (!seqDone)
        longjmp (env, -425);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecScaleVideoContent */




AsnLen
BEncScrollItemsContent PARAMS ((b, v),
BUF_TYPE b _AND_
ScrollItems *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->items_to_scroll));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncScrollItemsContent */

void
BDecScrollItemsContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ScrollItems *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -426);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->items_to_scroll) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->items_to_scroll), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->items_to_scroll), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -427);
    }
    else
        longjmp (env, -428);


    if (!seqDone)
        longjmp (env, -429);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecScrollItemsContent */




AsnLen
BEncSelectItemContent PARAMS ((b, v),
BUF_TYPE b _AND_
SelectItem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->item_index));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSelectItemContent */

void
BDecSelectItemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SelectItem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -430);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->item_index) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->item_index), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->item_index), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -431);
    }
    else
        longjmp (env, -432);


    if (!seqDone)
        longjmp (env, -433);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSelectItemContent */




AsnLen
BEncSetBoxSizeContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetBoxSize *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->y_new_box_size));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x_new_box_size));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetBoxSizeContent */

void
BDecSetBoxSizeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetBoxSize *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -434);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x_new_box_size) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x_new_box_size), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x_new_box_size), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -435);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y_new_box_size) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y_new_box_size), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y_new_box_size), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -436);
    }
    else
        longjmp (env, -437);


    if (!seqDone)
        longjmp (env, -438);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetBoxSizeContent */




AsnLen
BEncSetCachePriorityContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetCachePriority *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_cache_priority));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetCachePriorityContent */

void
BDecSetCachePriorityContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetCachePriority *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -439);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_cache_priority) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_cache_priority), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_cache_priority), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -440);
    }
    else
        longjmp (env, -441);


    if (!seqDone)
        longjmp (env, -442);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetCachePriorityContent */




AsnLen
BEncSetCounterEndPositionContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetCounterEndPosition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_counter_end_position));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetCounterEndPositionContent */

void
BDecSetCounterEndPositionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetCounterEndPosition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -443);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_counter_end_position) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_counter_end_position), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_counter_end_position), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -444);
    }
    else
        longjmp (env, -445);


    if (!seqDone)
        longjmp (env, -446);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetCounterEndPositionContent */




AsnLen
BEncSetCounterPositionContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetCounterPosition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_counter_position));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetCounterPositionContent */

void
BDecSetCounterPositionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetCounterPosition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -447);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_counter_position) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_counter_position), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_counter_position), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -448);
    }
    else
        longjmp (env, -449);


    if (!seqDone)
        longjmp (env, -450);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetCounterPositionContent */




AsnLen
BEncSetCounterTriggerContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetCounterTrigger *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->new_counter_value)))
    {
    itemLen = BEncGenericIntegerContent (b, (v->new_counter_value));

    totalLen += itemLen;
    }

    itemLen = BEncGenericIntegerContent (b, (v->trigger_identifier));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetCounterTriggerContent */

void
BDecSetCounterTriggerContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetCounterTrigger *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -451);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->trigger_identifier) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->trigger_identifier), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->trigger_identifier), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -452);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_counter_value) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_counter_value), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_counter_value), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -453);
    }


    if (!seqDone)
        longjmp (env, -454);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetCounterTriggerContent */




AsnLen
BEncSetCursorPositionContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetCursorPosition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->y_cursor));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x_cursor));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetCursorPositionContent */

void
BDecSetCursorPositionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetCursorPosition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -455);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x_cursor) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x_cursor), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x_cursor), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -456);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y_cursor) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y_cursor), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y_cursor), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -457);
    }
    else
        longjmp (env, -458);


    if (!seqDone)
        longjmp (env, -459);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetCursorPositionContent */




AsnLen
BEncSetCursorShapeContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetCursorShape *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->new_cursor_shape)))
    {
    itemLen = BEncGenericObjectReferenceContent (b, (v->new_cursor_shape));

    totalLen += itemLen;
    }

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetCursorShapeContent */

void
BDecSetCursorShapeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetCursorShape *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -460);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_cursor_shape) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->new_cursor_shape), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->new_cursor_shape), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -461);
    }


    if (!seqDone)
        longjmp (env, -462);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetCursorShapeContent */




AsnLen
BEncSetEntryPointContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetEntryPoint *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_entry_point));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetEntryPointContent */

void
BDecSetEntryPointContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetEntryPoint *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -463);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_entry_point) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_entry_point), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_entry_point), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -464);
    }
    else
        longjmp (env, -465);


    if (!seqDone)
        longjmp (env, -466);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetEntryPointContent */




AsnLen
BEncSetFirstItemContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetFirstItem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_first_item));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetFirstItemContent */

void
BDecSetFirstItemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetFirstItem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -467);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_first_item) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_first_item), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_first_item), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -468);
    }
    else
        longjmp (env, -469);


    if (!seqDone)
        longjmp (env, -470);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetFirstItemContent */




AsnLen
BEncSetHighlightStatusContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetHighlightStatus *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericBooleanContent (b, (v->new_highlight_status));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetHighlightStatusContent */

void
BDecSetHighlightStatusContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetHighlightStatus *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -471);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_highlight_status) = (GenericBoolean*) Asn1Alloc (sizeof (GenericBoolean));
    CheckAsn1Alloc ((v->new_highlight_status), env);
    BDecGenericBooleanContent (b, tagId1, elmtLen1, (v->new_highlight_status), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -472);
    }
    else
        longjmp (env, -473);


    if (!seqDone)
        longjmp (env, -474);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetHighlightStatusContent */




AsnLen
BEncSetInteractionStatusContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetInteractionStatus *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericBooleanContent (b, (v->new_interaction_status));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetInteractionStatusContent */

void
BDecSetInteractionStatusContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetInteractionStatus *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -475);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_interaction_status) = (GenericBoolean*) Asn1Alloc (sizeof (GenericBoolean));
    CheckAsn1Alloc ((v->new_interaction_status), env);
    BDecGenericBooleanContent (b, tagId1, elmtLen1, (v->new_interaction_status), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -476);
    }
    else
        longjmp (env, -477);


    if (!seqDone)
        longjmp (env, -478);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetInteractionStatusContent */




AsnLen
BEncSetLabelContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetLabel *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericOctetStringContent (b, (v->new_label));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetLabelContent */

void
BDecSetLabelContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetLabel *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -479);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_label) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->new_label), env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->new_label), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -480);
    }
    else
        longjmp (env, -481);


    if (!seqDone)
        longjmp (env, -482);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetLabelContent */




AsnLen
BEncSetLineStyleContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetLineStyle *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_line_style));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetLineStyleContent */

void
BDecSetLineStyleContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetLineStyle *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -483);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_line_style) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_line_style), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_line_style), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -484);
    }
    else
        longjmp (env, -485);


    if (!seqDone)
        longjmp (env, -486);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetLineStyleContent */




AsnLen
BEncSetLineWidthContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetLineWidth *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_line_width));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetLineWidthContent */

void
BDecSetLineWidthContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetLineWidth *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -487);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_line_width) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_line_width), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_line_width), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -488);
    }
    else
        longjmp (env, -489);


    if (!seqDone)
        longjmp (env, -490);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetLineWidthContent */




AsnLen
BEncSetOverwriteModeContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetOverwriteMode *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericBooleanContent (b, (v->new_overwrite_mode));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetOverwriteModeContent */

void
BDecSetOverwriteModeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetOverwriteMode *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -491);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_overwrite_mode) = (GenericBoolean*) Asn1Alloc (sizeof (GenericBoolean));
    CheckAsn1Alloc ((v->new_overwrite_mode), env);
    BDecGenericBooleanContent (b, tagId1, elmtLen1, (v->new_overwrite_mode), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -492);
    }
    else
        longjmp (env, -493);


    if (!seqDone)
        longjmp (env, -494);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetOverwriteModeContent */




AsnLen
BEncSetPaletteRefContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetPaletteRef *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericObjectReferenceContent (b, (v->new_palette_ref));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetPaletteRefContent */

void
BDecSetPaletteRefContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetPaletteRef *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -495);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_palette_ref) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->new_palette_ref), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->new_palette_ref), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -496);
    }
    else
        longjmp (env, -497);


    if (!seqDone)
        longjmp (env, -498);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetPaletteRefContent */




AsnLen
BEncSetPortionContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetPortion *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_portion));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetPortionContent */

void
BDecSetPortionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetPortion *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -499);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_portion) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_portion), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_portion), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -500);
    }
    else
        longjmp (env, -501);


    if (!seqDone)
        longjmp (env, -502);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetPortionContent */




AsnLen
BEncSetPositionContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetPosition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_y_position));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->new_x_position));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetPositionContent */

void
BDecSetPositionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetPosition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -503);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_x_position) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_x_position), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_x_position), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -504);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_y_position) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_y_position), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_y_position), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -505);
    }
    else
        longjmp (env, -506);


    if (!seqDone)
        longjmp (env, -507);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetPositionContent */




AsnLen
BEncSetSliderValueContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetSliderValue *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_slider_value));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetSliderValueContent */

void
BDecSetSliderValueContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetSliderValue *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -508);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_slider_value) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_slider_value), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_slider_value), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -509);
    }
    else
        longjmp (env, -510);


    if (!seqDone)
        longjmp (env, -511);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetSliderValueContent */




AsnLen
BEncNewTimerContent PARAMS ((b, v),
BUF_TYPE b _AND_
NewTimer *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->absolute_time)))
    {
    itemLen = BEncGenericBooleanContent (b, (v->absolute_time));

    totalLen += itemLen;
    }

    itemLen = BEncGenericIntegerContent (b, (v->timer_value));

    totalLen += itemLen;

    return totalLen;

}  /* BEncNewTimerContent */

void
BDecNewTimerContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NewTimer *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->timer_value) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->timer_value), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->timer_value), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -512);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (UNIV, PRIM, BOOLEAN_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->absolute_time) = (GenericBoolean*) Asn1Alloc (sizeof (GenericBoolean));
    CheckAsn1Alloc ((v->absolute_time), env);
    BDecGenericBooleanContent (b, tagId1, elmtLen1, (v->absolute_time), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -513);
    }


    if (!seqDone)
        longjmp (env, -514);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNewTimerContent */




AsnLen
BEncSetTransparencyContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetTransparency *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_transparency));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetTransparencyContent */

void
BDecSetTransparencyContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetTransparency *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -515);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_transparency) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_transparency), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_transparency), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -516);
    }
    else
        longjmp (env, -517);


    if (!seqDone)
        longjmp (env, -518);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetTransparencyContent */




AsnLen
BEncSetVolumeContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetVolume *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_volume));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetVolumeContent */

void
BDecSetVolumeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetVolume *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -519);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_volume) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_volume), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_volume), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -520);
    }
    else
        longjmp (env, -521);


    if (!seqDone)
        longjmp (env, -522);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetVolumeContent */




AsnLen
BEncStepContent PARAMS ((b, v),
BUF_TYPE b _AND_
Step *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->nb_of_steps));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncStepContent */

void
BDecStepContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Step *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -523);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->nb_of_steps) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->nb_of_steps), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->nb_of_steps), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -524);
    }
    else
        longjmp (env, -525);


    if (!seqDone)
        longjmp (env, -526);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecStepContent */




AsnLen
BEncStorePersistentContent PARAMS ((b, v),
BUF_TYPE b _AND_
StorePersistent *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericOctetStringContent (b, (v->out_file_name));

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncStorePersistentSeqOfContent (b, (v->in_variables));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;

    itemLen = BEncObjectReferenceContent (b, (v->store_succeeded));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncStorePersistentContent */

void
BDecStorePersistentContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
StorePersistent *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -527);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->store_succeeded) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->store_succeeded), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->store_succeeded), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -528);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->in_variables) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->in_variables), env);
    BDecStorePersistentSeqOfContent (b, tagId1, elmtLen1, (v->in_variables), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -529);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->out_file_name) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->out_file_name), env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->out_file_name), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -530);
    }
    else
        longjmp (env, -531);


    if (!seqDone)
        longjmp (env, -532);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecStorePersistentContent */




AsnLen
BEncSubtractContent PARAMS ((b, v),
BUF_TYPE b _AND_
Subtract *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->value));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSubtractContent */

void
BDecSubtractContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Subtract *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -533);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->value) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->value), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->value), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -534);
    }
    else
        longjmp (env, -535);


    if (!seqDone)
        longjmp (env, -536);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSubtractContent */




AsnLen
BEncToggleItemContent PARAMS ((b, v),
BUF_TYPE b _AND_
ToggleItem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->item_index));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncToggleItemContent */

void
BDecToggleItemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ToggleItem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -537);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->item_index) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->item_index), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->item_index), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -538);
    }
    else
        longjmp (env, -539);


    if (!seqDone)
        longjmp (env, -540);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecToggleItemContent */




AsnLen
BEncSetFontAttributesContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetFontAttributes *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericOctetStringContent (b, (v->new_font_attributes));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetFontAttributesContent */

void
BDecSetFontAttributesContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetFontAttributes *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -541);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_font_attributes) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->new_font_attributes), env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->new_font_attributes), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -542);
    }
    else
        longjmp (env, -543);


    if (!seqDone)
        longjmp (env, -544);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetFontAttributesContent */




AsnLen
BEncSetInputRegisterContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetInputRegister *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_input_register));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetInputRegisterContent */

void
BDecSetInputRegisterContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetInputRegister *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -545);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_input_register) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_input_register), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_input_register), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -546);
    }
    else
        longjmp (env, -547);


    if (!seqDone)
        longjmp (env, -548);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetInputRegisterContent */




AsnLen
BEncSetCellPositionContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetCellPosition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_y_position));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->new_x_position));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->index));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetCellPositionContent */

void
BDecSetCellPositionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetCellPosition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -549);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->index) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->index), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->index), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -550);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_x_position) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_x_position), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_x_position), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -551);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_y_position) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_y_position), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_y_position), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -552);
    }
    else
        longjmp (env, -553);


    if (!seqDone)
        longjmp (env, -554);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetCellPositionContent */




AsnLen
BEncSetPositionOffsetContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetPositionOffset *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_y_offset));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->new_x_offset));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetPositionOffsetContent */

void
BDecSetPositionOffsetContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetPositionOffset *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -555);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_x_offset) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_x_offset), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_x_offset), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -556);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_y_offset) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_y_offset), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_y_offset), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -557);
    }
    else
        longjmp (env, -558);


    if (!seqDone)
        longjmp (env, -559);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetPositionOffsetContent */




AsnLen
BEncGetPositionOffsetContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetPositionOffset *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->y_offset_var));

    totalLen += itemLen;

    itemLen = BEncObjectReferenceContent (b, (v->x_offset_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetPositionOffsetContent */

void
BDecGetPositionOffsetContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetPositionOffset *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -560);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x_offset_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->x_offset_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->x_offset_var), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -561);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y_offset_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->y_offset_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->y_offset_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -562);
    }
    else
        longjmp (env, -563);


    if (!seqDone)
        longjmp (env, -564);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetPositionOffsetContent */




AsnLen
BEncSetFocusPositionContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetFocusPosition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_focus_position));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetFocusPositionContent */

void
BDecSetFocusPositionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetFocusPosition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -565);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_focus_position) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_focus_position), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_focus_position), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -566);
    }
    else
        longjmp (env, -567);


    if (!seqDone)
        longjmp (env, -568);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetFocusPositionContent */




AsnLen
BEncGetFocusPositionContent PARAMS ((b, v),
BUF_TYPE b _AND_
GetFocusPosition *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncObjectReferenceContent (b, (v->focus_position_var));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGetFocusPositionContent */

void
BDecGetFocusPositionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GetFocusPosition *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -569);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->focus_position_var) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->focus_position_var), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->focus_position_var), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -570);
    }
    else
        longjmp (env, -571);


    if (!seqDone)
        longjmp (env, -572);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGetFocusPositionContent */




AsnLen
BEncSetSliderParametersContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetSliderParameters *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->new_step_size));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->new_max_value));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->new_min_value));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetSliderParametersContent */

void
BDecSetSliderParametersContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetSliderParameters *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -565);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_min_value) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_min_value), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_min_value), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -556);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_max_value) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_max_value), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_max_value), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -556);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_step_size) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_step_size), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->new_step_size), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -566);
    }
    else
        longjmp (env, -567);


    if (!seqDone)
        longjmp (env, -568);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetSliderParametersContent */




AsnLen
BEncConnectionTagOrNullContent PARAMS ((b, v),
BUF_TYPE b _AND_
ConnectionTagOrNull *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case CONNECTIONTAGORNULL_CONNECTION_TAG:
    itemLen = BEncGenericIntegerContent (b, (v->a.connection_tag));

    totalLen += itemLen;

    break;

       case CONNECTIONTAGORNULL_NULL:
    itemLen = BEncAsnNullContent (b, (&v->a.null));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 5);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncConnectionTagOrNullContent */

void
BDecConnectionTagOrNullContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ConnectionTagOrNull *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
       case MAKE_TAG_ID (CNTX, CONS, 236):
        (v->choiceId) = CONNECTIONTAGORNULL_CONNECTION_TAG;
    (v->a.connection_tag) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->a.connection_tag), env);
    BDecGenericIntegerContent (b, tagId0, elmtLen0, (v->a.connection_tag), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, PRIM, NULLTYPE_TAG_CODE):
        (v->choiceId) = CONNECTIONTAGORNULL_NULL;
    BDecAsnNullContent (b, tagId0, elmtLen0, (&v->a.null), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -573);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecConnectionTagOrNullContent */




AsnLen
BEncComparisonValueContent PARAMS ((b, v),
BUF_TYPE b _AND_
ComparisonValue *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case COMPARISONVALUE_NEW_GENERIC_BOOLEAN:
    BEncEocIfNec (b);
    itemLen = BEncGenericBooleanContent (b, (v->a.new_generic_boolean));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 225);

    totalLen += itemLen;

    break;

       case COMPARISONVALUE_NEW_GENERIC_INTEGER:
    BEncEocIfNec (b);
    itemLen = BEncGenericIntegerContent (b, (v->a.new_generic_integer));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 226);

    totalLen += itemLen;

    break;

       case COMPARISONVALUE_NEW_GENERIC_OCTETSTRING:
    BEncEocIfNec (b);
    itemLen = BEncGenericOctetStringContent (b, (v->a.new_generic_octetstring));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 227);

    totalLen += itemLen;

    break;

       case COMPARISONVALUE_NEW_GENERIC_OBJECT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.new_generic_object_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 228);

    totalLen += itemLen;

    break;

       case COMPARISONVALUE_NEW_GENERIC_CONTENT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncGenericContentReferenceContent (b, (v->a.new_generic_content_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 229);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncComparisonValueContent */

void
BDecComparisonValueContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ComparisonValue *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, CONS, 225):
        (v->choiceId) = COMPARISONVALUE_NEW_GENERIC_BOOLEAN;
    (v->a.new_generic_boolean) = (GenericBoolean*) Asn1Alloc (sizeof (GenericBoolean));
    CheckAsn1Alloc ((v->a.new_generic_boolean), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericBooleanContent (b, tagId1, elmtLen1, (v->a.new_generic_boolean), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 226):
        (v->choiceId) = COMPARISONVALUE_NEW_GENERIC_INTEGER;
    (v->a.new_generic_integer) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->a.new_generic_integer), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->a.new_generic_integer), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 227):
        (v->choiceId) = COMPARISONVALUE_NEW_GENERIC_OCTETSTRING;
    (v->a.new_generic_octetstring) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->a.new_generic_octetstring), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->a.new_generic_octetstring), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 228):
        (v->choiceId) = COMPARISONVALUE_NEW_GENERIC_OBJECT_REFERENCE;
    (v->a.new_generic_object_reference) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.new_generic_object_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.new_generic_object_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 229):
        (v->choiceId) = COMPARISONVALUE_NEW_GENERIC_CONTENT_REFERENCE;
    (v->a.new_generic_content_reference) = (GenericContentReference*) Asn1Alloc (sizeof (GenericContentReference));
    CheckAsn1Alloc ((v->a.new_generic_content_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericContentReferenceContent (b, tagId1, elmtLen1, (v->a.new_generic_content_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -574);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecComparisonValueContent */




AsnLen
BEncEmulatedEventDataContent PARAMS ((b, v),
BUF_TYPE b _AND_
EmulatedEventData *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case EMULATEDEVENTDATA_NEW_GENERIC_BOOLEAN:
    BEncEocIfNec (b);
    itemLen = BEncGenericBooleanContent (b, (v->a.new_generic_boolean));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 225);

    totalLen += itemLen;

    break;

       case EMULATEDEVENTDATA_NEW_GENERIC_INTEGER:
    BEncEocIfNec (b);
    itemLen = BEncGenericIntegerContent (b, (v->a.new_generic_integer));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 226);

    totalLen += itemLen;

    break;

       case EMULATEDEVENTDATA_NEW_GENERIC_OCTET_STRING:
    BEncEocIfNec (b);
    itemLen = BEncGenericOctetStringContent (b, (v->a.new_generic_octet_string));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 227);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncEmulatedEventDataContent */

void
BDecEmulatedEventDataContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
EmulatedEventData *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, CONS, 225):
        (v->choiceId) = EMULATEDEVENTDATA_NEW_GENERIC_BOOLEAN;
    (v->a.new_generic_boolean) = (GenericBoolean*) Asn1Alloc (sizeof (GenericBoolean));
    CheckAsn1Alloc ((v->a.new_generic_boolean), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericBooleanContent (b, tagId1, elmtLen1, (v->a.new_generic_boolean), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 226):
        (v->choiceId) = EMULATEDEVENTDATA_NEW_GENERIC_INTEGER;
    (v->a.new_generic_integer) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->a.new_generic_integer), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->a.new_generic_integer), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 227):
        (v->choiceId) = EMULATEDEVENTDATA_NEW_GENERIC_OCTET_STRING;
    (v->a.new_generic_octet_string) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->a.new_generic_octet_string), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->a.new_generic_octet_string), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -575);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecEmulatedEventDataContent */




AsnLen
BEncNewColourContent PARAMS ((b, v),
BUF_TYPE b _AND_
NewColour *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case NEWCOLOUR_NEW_COLOUR_INDEX:
    BEncEocIfNec (b);
    itemLen = BEncGenericIntegerContent (b, (v->a.new_colour_index));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 230);

    totalLen += itemLen;

    break;

       case NEWCOLOUR_NEW_ABSOLUTE_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncGenericOctetStringContent (b, (v->a.new_absolute_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 231);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncNewColourContent */

void
BDecNewColourContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NewColour *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, CONS, 230):
        (v->choiceId) = NEWCOLOUR_NEW_COLOUR_INDEX;
    (v->a.new_colour_index) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->a.new_colour_index), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->a.new_colour_index), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 231):
        (v->choiceId) = NEWCOLOUR_NEW_ABSOLUTE_COLOUR;
    (v->a.new_absolute_colour) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->a.new_absolute_colour), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->a.new_absolute_colour), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -576);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNewColourContent */




AsnLen
BEncNewFontContent PARAMS ((b, v),
BUF_TYPE b _AND_
NewFont *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case NEWFONT_NEW_FONT_NAME:
    BEncEocIfNec (b);
    itemLen = BEncGenericOctetStringContent (b, (v->a.new_font_name));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 232);

    totalLen += itemLen;

    break;

       case NEWFONT_NEW_FONT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.new_font_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 233);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncNewFontContent */

void
BDecNewFontContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NewFont *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, CONS, 232):
        (v->choiceId) = NEWFONT_NEW_FONT_NAME;
    (v->a.new_font_name) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->a.new_font_name), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->a.new_font_name), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 233):
        (v->choiceId) = NEWFONT_NEW_FONT_REFERENCE;
    (v->a.new_font_reference) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.new_font_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.new_font_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -577);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNewFontContent */




AsnLen
BEncNewContentSizeContent PARAMS ((b, v),
BUF_TYPE b _AND_
NewContentSize *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case NEWCONTENTSIZE_CONTENT_SIZE:
    itemLen = BEncGenericIntegerContent (b, (v->a.content_size));

    totalLen += itemLen;

    break;

       case NEWCONTENTSIZE_NULL:
    itemLen = BEncAsnNullContent (b, (&v->a.null));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 5);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncNewContentSizeContent */

void
BDecNewContentSizeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NewContentSize *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
       case MAKE_TAG_ID (CNTX, CONS, 236):
        (v->choiceId) = NEWCONTENTSIZE_CONTENT_SIZE;
    (v->a.content_size) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->a.content_size), env);
    BDecGenericIntegerContent (b, tagId0, elmtLen0, (v->a.content_size), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, PRIM, NULLTYPE_TAG_CODE):
        (v->choiceId) = NEWCONTENTSIZE_NULL;
    BDecAsnNullContent (b, tagId0, elmtLen0, (&v->a.null), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -578);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNewContentSizeContent */




AsnLen
BEncNewVariableValueContent PARAMS ((b, v),
BUF_TYPE b _AND_
NewVariableValue *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case NEWVARIABLEVALUE_NEW_GENERIC_INTEGER:
    BEncEocIfNec (b);
    itemLen = BEncGenericIntegerContent (b, (v->a.new_generic_integer));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 226);

    totalLen += itemLen;

    break;

       case NEWVARIABLEVALUE_NEW_GENERIC_BOOLEAN:
    BEncEocIfNec (b);
    itemLen = BEncGenericBooleanContent (b, (v->a.new_generic_boolean));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 225);

    totalLen += itemLen;

    break;

       case NEWVARIABLEVALUE_NEW_GENERIC_OCTET_STRING:
    BEncEocIfNec (b);
    itemLen = BEncGenericOctetStringContent (b, (v->a.new_generic_octet_string));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 227);

    totalLen += itemLen;

    break;

       case NEWVARIABLEVALUE_NEW_GENERIC_OBJECT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.new_generic_object_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 228);

    totalLen += itemLen;

    break;

       case NEWVARIABLEVALUE_NEW_GENERIC_CONTENT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncGenericContentReferenceContent (b, (v->a.new_generic_content_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 229);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncNewVariableValueContent */

void
BDecNewVariableValueContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NewVariableValue *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, CONS, 226):
        (v->choiceId) = NEWVARIABLEVALUE_NEW_GENERIC_INTEGER;
    (v->a.new_generic_integer) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->a.new_generic_integer), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->a.new_generic_integer), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 225):
        (v->choiceId) = NEWVARIABLEVALUE_NEW_GENERIC_BOOLEAN;
    (v->a.new_generic_boolean) = (GenericBoolean*) Asn1Alloc (sizeof (GenericBoolean));
    CheckAsn1Alloc ((v->a.new_generic_boolean), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericBooleanContent (b, tagId1, elmtLen1, (v->a.new_generic_boolean), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 227):
        (v->choiceId) = NEWVARIABLEVALUE_NEW_GENERIC_OCTET_STRING;
    (v->a.new_generic_octet_string) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->a.new_generic_octet_string), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->a.new_generic_octet_string), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 228):
        (v->choiceId) = NEWVARIABLEVALUE_NEW_GENERIC_OBJECT_REFERENCE;
    (v->a.new_generic_object_reference) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.new_generic_object_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.new_generic_object_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 229):
        (v->choiceId) = NEWVARIABLEVALUE_NEW_GENERIC_CONTENT_REFERENCE;
    (v->a.new_generic_content_reference) = (GenericContentReference*) Asn1Alloc (sizeof (GenericContentReference));
    CheckAsn1Alloc ((v->a.new_generic_content_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericContentReferenceContent (b, tagId1, elmtLen1, (v->a.new_generic_content_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -579);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNewVariableValueContent */




AsnLen
BEncParameterContent PARAMS ((b, v),
BUF_TYPE b _AND_
Parameter *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case PARAMETER_NEW_GENERIC_BOOLEAN:
    BEncEocIfNec (b);
    itemLen = BEncGenericBooleanContent (b, (v->a.new_generic_boolean));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 225);

    totalLen += itemLen;

    break;

       case PARAMETER_NEW_GENERIC_INTEGER:
    BEncEocIfNec (b);
    itemLen = BEncGenericIntegerContent (b, (v->a.new_generic_integer));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 226);

    totalLen += itemLen;

    break;

       case PARAMETER_NEW_GENERIC_OCTETSTRING:
    BEncEocIfNec (b);
    itemLen = BEncGenericOctetStringContent (b, (v->a.new_generic_octetstring));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 227);

    totalLen += itemLen;

    break;

       case PARAMETER_NEW_GENERIC_OBJECT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.new_generic_object_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 228);

    totalLen += itemLen;

    break;

       case PARAMETER_NEW_GENERIC_CONTENT_REFERENCE:
    BEncEocIfNec (b);
    itemLen = BEncGenericContentReferenceContent (b, (v->a.new_generic_content_reference));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 229);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncParameterContent */

void
BDecParameterContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Parameter *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, CONS, 225):
        (v->choiceId) = PARAMETER_NEW_GENERIC_BOOLEAN;
    (v->a.new_generic_boolean) = (GenericBoolean*) Asn1Alloc (sizeof (GenericBoolean));
    CheckAsn1Alloc ((v->a.new_generic_boolean), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericBooleanContent (b, tagId1, elmtLen1, (v->a.new_generic_boolean), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 226):
        (v->choiceId) = PARAMETER_NEW_GENERIC_INTEGER;
    (v->a.new_generic_integer) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->a.new_generic_integer), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->a.new_generic_integer), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 227):
        (v->choiceId) = PARAMETER_NEW_GENERIC_OCTETSTRING;
    (v->a.new_generic_octetstring) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->a.new_generic_octetstring), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericOctetStringContent (b, tagId1, elmtLen1, (v->a.new_generic_octetstring), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 228):
        (v->choiceId) = PARAMETER_NEW_GENERIC_OBJECT_REFERENCE;
    (v->a.new_generic_object_reference) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.new_generic_object_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.new_generic_object_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 229):
        (v->choiceId) = PARAMETER_NEW_GENERIC_CONTENT_REFERENCE;
    (v->a.new_generic_content_reference) = (GenericContentReference*) Asn1Alloc (sizeof (GenericContentReference));
    CheckAsn1Alloc ((v->a.new_generic_content_reference), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericContentReferenceContent (b, tagId1, elmtLen1, (v->a.new_generic_content_reference), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -580);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecParameterContent */




AsnLen
BEncPointContent PARAMS ((b, v),
BUF_TYPE b _AND_
Point *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncGenericIntegerContent (b, (v->y));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->x));

    totalLen += itemLen;

    return totalLen;

}  /* BEncPointContent */

void
BDecPointContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Point *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->x) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->x), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->x), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -581);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->y) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->y), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->y), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -582);
    }
    else
        longjmp (env, -583);


    if (!seqDone)
        longjmp (env, -584);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecPointContent */




AsnLen
BEncRationalContent PARAMS ((b, v),
BUF_TYPE b _AND_
Rational *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->denominator)))
    {
    itemLen = BEncGenericIntegerContent (b, (v->denominator));

    totalLen += itemLen;
    }

    itemLen = BEncGenericIntegerContent (b, (v->numerator));

    totalLen += itemLen;

    return totalLen;

}  /* BEncRationalContent */

void
BDecRationalContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Rational *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->numerator) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->numerator), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->numerator), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -585);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->denominator) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->denominator), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->denominator), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -586);
    }


    if (!seqDone)
        longjmp (env, -587);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecRationalContent */




AsnLen
BEncForkSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
ForkSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncParameterContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncForkSeqOfContent */

void
BDecForkSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ForkSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        Parameter **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (Parameter**) AsnListAppend (v);
    (*tmpVar) = (Parameter*) Asn1Alloc (sizeof (Parameter));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecParameterContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecForkSeqOfContent */




AsnLen
BEncDrawPolylineSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
DrawPolylineSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncPointContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncDrawPolylineSeqOfContent */

void
BDecDrawPolylineSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DrawPolylineSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        Point **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (Point**) AsnListAppend (v);
    (*tmpVar) = (Point*) Asn1Alloc (sizeof (Point));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecPointContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -588);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDrawPolylineSeqOfContent */




AsnLen
BEncDrawPolygonSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
DrawPolygonSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncPointContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncDrawPolygonSeqOfContent */

void
BDecDrawPolygonSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DrawPolygonSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        Point **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (Point**) AsnListAppend (v);
    (*tmpVar) = (Point*) Asn1Alloc (sizeof (Point));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecPointContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -589);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDrawPolygonSeqOfContent */




AsnLen
BEncCallSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
CallSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncParameterContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncCallSeqOfContent */

void
BDecCallSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
CallSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        Parameter **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (Parameter**) AsnListAppend (v);
    (*tmpVar) = (Parameter*) Asn1Alloc (sizeof (Parameter));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecParameterContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCallSeqOfContent */




AsnLen
BEncDefaultAttributeContent PARAMS ((b, v),
BUF_TYPE b _AND_
DefaultAttribute *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case DEFAULTATTRIBUTE_CHARACTER_SET:
    itemLen = BEncAsnIntContent (b, (&v->a.character_set));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 38);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_BACKGROUND_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->a.background_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 39);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_TEXT_CONTENT_HOOK:
    itemLen = BEncAsnIntContent (b, (&v->a.text_content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 40);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_TEXT_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->a.text_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 41);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_FONT:
    BEncEocIfNec (b);
    itemLen = BEncFontBodyContent (b, (v->a.font));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 42);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_FONT_ATTRIBUTES:
    itemLen = BEncAsnOctsContent (b, (v->a.font_attributes));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, PRIM, 43);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_INTERCHANGED_PROGRAM_CONTENT_HOOK:
    itemLen = BEncAsnIntContent (b, (&v->a.interchanged_program_content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 44);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_STREAM_CONTENT_HOOK:
    itemLen = BEncAsnIntContent (b, (&v->a.stream_content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 45);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_BITMAP_CONTENT_HOOK:
    itemLen = BEncAsnIntContent (b, (&v->a.bitmap_content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 46);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_LINE_ART_CONTENT_HOOK:
    itemLen = BEncAsnIntContent (b, (&v->a.line_art_content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 47);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_BUTTON_REF_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->a.button_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 48);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_HIGHLIGHT_REF_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->a.highlight_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 49);

    totalLen += itemLen;

    break;

       case DEFAULTATTRIBUTE_SLIDER_REF_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->a.slider_ref_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 50);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncDefaultAttributeContent */

void
BDecDefaultAttributeContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DefaultAttribute *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, PRIM, 38):
        (v->choiceId) = DEFAULTATTRIBUTE_CHARACTER_SET;
    BDecAsnIntContent (b, tagId0, elmtLen0, (&v->a.character_set), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 39):
        (v->choiceId) = DEFAULTATTRIBUTE_BACKGROUND_COLOUR;
    (v->a.background_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->a.background_colour), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId1, elmtLen1, (v->a.background_colour), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 40):
        (v->choiceId) = DEFAULTATTRIBUTE_TEXT_CONTENT_HOOK;
    BDecAsnIntContent (b, tagId0, elmtLen0, (&v->a.text_content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 41):
        (v->choiceId) = DEFAULTATTRIBUTE_TEXT_COLOUR;
    (v->a.text_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->a.text_colour), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId1, elmtLen1, (v->a.text_colour), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 42):
        (v->choiceId) = DEFAULTATTRIBUTE_FONT;
    (v->a.font) = (FontBody*) Asn1Alloc (sizeof (FontBody));
    CheckAsn1Alloc ((v->a.font), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecFontBodyContent (b, tagId1, elmtLen1, (v->a.font), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 43):
       case MAKE_TAG_ID (CNTX, CONS, 43):
        (v->choiceId) = DEFAULTATTRIBUTE_FONT_ATTRIBUTES;
    (v->a.font_attributes) = (AsnOcts*) Asn1Alloc (sizeof (AsnOcts));
    CheckAsn1Alloc ((v->a.font_attributes), env);
    BDecAsnOctsContent (b, tagId0, elmtLen0, (v->a.font_attributes), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 44):
        (v->choiceId) = DEFAULTATTRIBUTE_INTERCHANGED_PROGRAM_CONTENT_HOOK;
    BDecAsnIntContent (b, tagId0, elmtLen0, (&v->a.interchanged_program_content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 45):
        (v->choiceId) = DEFAULTATTRIBUTE_STREAM_CONTENT_HOOK;
    BDecAsnIntContent (b, tagId0, elmtLen0, (&v->a.stream_content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 46):
        (v->choiceId) = DEFAULTATTRIBUTE_BITMAP_CONTENT_HOOK;
    BDecAsnIntContent (b, tagId0, elmtLen0, (&v->a.bitmap_content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 47):
        (v->choiceId) = DEFAULTATTRIBUTE_LINE_ART_CONTENT_HOOK;
    BDecAsnIntContent (b, tagId0, elmtLen0, (&v->a.line_art_content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 48):
        (v->choiceId) = DEFAULTATTRIBUTE_BUTTON_REF_COLOUR;
    (v->a.button_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->a.button_ref_colour), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId1, elmtLen1, (v->a.button_ref_colour), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 49):
        (v->choiceId) = DEFAULTATTRIBUTE_HIGHLIGHT_REF_COLOUR;
    (v->a.highlight_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->a.highlight_ref_colour), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId1, elmtLen1, (v->a.highlight_ref_colour), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 50):
        (v->choiceId) = DEFAULTATTRIBUTE_SLIDER_REF_COLOUR;
    (v->a.slider_ref_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->a.slider_ref_colour), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId1, elmtLen1, (v->a.slider_ref_colour), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -590);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDefaultAttributeContent */




AsnLen
BEncIngredientClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
IngredientClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncIngredientClassContent */

void
BDecIngredientClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
IngredientClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecIngredientClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -591);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 1)
    {
        Asn1Error ("BDecIngredientClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -592);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecIngredientClassContent */




AsnLen
BEncVariableClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
VariableClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncOriginalValueContent (b, (v->original_value));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 67);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncVariableClassContent */

void
BDecVariableClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
VariableClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 67):
    (v->original_value) = (OriginalValue*) Asn1Alloc (sizeof (OriginalValue));
    CheckAsn1Alloc ((v->original_value), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecOriginalValueContent (b, tagId2, elmtLen2, (v->original_value), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

    default:
        Asn1Error ("BDecVariableClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -593);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecVariableClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -594);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecVariableClassContent */




AsnLen
BEncStreamComponentContent PARAMS ((b, v),
BUF_TYPE b _AND_
StreamComponent *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case STREAMCOMPONENT_AUDIO:
    BEncEocIfNec (b);
    itemLen = BEncAudioClassContent (b, (v->a.audio));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 95);

    totalLen += itemLen;

    break;

       case STREAMCOMPONENT_VIDEO:
    BEncEocIfNec (b);
    itemLen = BEncVideoClassContent (b, (v->a.video));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 96);

    totalLen += itemLen;

    break;

       case STREAMCOMPONENT_RTGRAPHICS:
    BEncEocIfNec (b);
    itemLen = BEncRTGraphicsClassContent (b, (v->a.rtgraphics));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 97);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncStreamComponentContent */

void
BDecStreamComponentContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
StreamComponent *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, CONS, 95):
        (v->choiceId) = STREAMCOMPONENT_AUDIO;
    (v->a.audio) = (AudioClass*) Asn1Alloc (sizeof (AudioClass));
    CheckAsn1Alloc ((v->a.audio), env);
    BDecAudioClassContent (b, tagId0, elmtLen0, (v->a.audio), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 96):
        (v->choiceId) = STREAMCOMPONENT_VIDEO;
    (v->a.video) = (VideoClass*) Asn1Alloc (sizeof (VideoClass));
    CheckAsn1Alloc ((v->a.video), env);
    BDecVideoClassContent (b, tagId0, elmtLen0, (v->a.video), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 97):
        (v->choiceId) = STREAMCOMPONENT_RTGRAPHICS;
    (v->a.rtgraphics) = (RTGraphicsClass*) Asn1Alloc (sizeof (RTGraphicsClass));
    CheckAsn1Alloc ((v->a.rtgraphics), env);
    BDecRTGraphicsClassContent (b, tagId0, elmtLen0, (v->a.rtgraphics), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -595);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecStreamComponentContent */




AsnLen
BEncCallContent PARAMS ((b, v),
BUF_TYPE b _AND_
Call *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->parameters)))
    {
    BEncEocIfNec (b);
    itemLen = BEncCallSeqOfContent (b, (v->parameters));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;
    }

    itemLen = BEncObjectReferenceContent (b, (v->call_succeeded));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncCallContent */

void
BDecCallContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Call *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -596);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->call_succeeded) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->call_succeeded), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->call_succeeded), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -597);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->parameters) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->parameters), env);
    BDecCallSeqOfContent (b, tagId1, elmtLen1, (v->parameters), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -598);
    }


    if (!seqDone)
        longjmp (env, -599);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecCallContent */




AsnLen
BEncDrawPolygonContent PARAMS ((b, v),
BUF_TYPE b _AND_
DrawPolygon *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncDrawPolygonSeqOfContent (b, (v->pointlist));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncDrawPolygonContent */

void
BDecDrawPolygonContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DrawPolygon *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -600);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->pointlist) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->pointlist), env);
    BDecDrawPolygonSeqOfContent (b, tagId1, elmtLen1, (v->pointlist), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -601);
    }
    else
        longjmp (env, -602);


    if (!seqDone)
        longjmp (env, -603);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDrawPolygonContent */




AsnLen
BEncDrawPolylineContent PARAMS ((b, v),
BUF_TYPE b _AND_
DrawPolyline *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncDrawPolylineSeqOfContent (b, (v->pointlist));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncDrawPolylineContent */

void
BDecDrawPolylineContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
DrawPolyline *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -604);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->pointlist) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->pointlist), env);
    BDecDrawPolylineSeqOfContent (b, tagId1, elmtLen1, (v->pointlist), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -605);
    }
    else
        longjmp (env, -606);


    if (!seqDone)
        longjmp (env, -607);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecDrawPolylineContent */




AsnLen
BEncForkContent PARAMS ((b, v),
BUF_TYPE b _AND_
Fork *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->parameters)))
    {
    BEncEocIfNec (b);
    itemLen = BEncForkSeqOfContent (b, (v->parameters));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;
    }

    itemLen = BEncObjectReferenceContent (b, (v->fork_succeeded));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncForkContent */

void
BDecForkContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
Fork *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -608);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->fork_succeeded) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->fork_succeeded), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->fork_succeeded), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -609);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->parameters) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->parameters), env);
    BDecForkSeqOfContent (b, tagId1, elmtLen1, (v->parameters), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -610);
    }


    if (!seqDone)
        longjmp (env, -611);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecForkContent */




AsnLen
BEncSendEventContent PARAMS ((b, v),
BUF_TYPE b _AND_
SendEvent *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->emulated_event_data)))
    {
    itemLen = BEncEmulatedEventDataContent (b, (v->emulated_event_data));

    totalLen += itemLen;
    }

    itemLen = BEncEventTypeContent (b, (&v->emulated_event_type));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 10);

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->emulated_event_source));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSendEventContent */

void
BDecSendEventContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SendEvent *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -612);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->emulated_event_source) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->emulated_event_source), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->emulated_event_source), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -613);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, ENUM_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecEventTypeContent (b, tagId1, elmtLen1, (&v->emulated_event_type), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -614);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (CNTX, CONS, 225)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 226)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 227))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->emulated_event_data) = (EmulatedEventData*) Asn1Alloc (sizeof (EmulatedEventData));
    CheckAsn1Alloc ((v->emulated_event_data), env);
    BDecEmulatedEventDataContent (b, tagId1, elmtLen1, (v->emulated_event_data), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -615);
    }


    if (!seqDone)
        longjmp (env, -616);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSendEventContent */




AsnLen
BEncSetFillColourContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetFillColour *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->new_fill_colour)))
    {
    itemLen = BEncNewColourContent (b, (v->new_fill_colour));

    totalLen += itemLen;
    }

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetFillColourContent */

void
BDecSetFillColourContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetFillColour *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -617);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (CNTX, CONS, 230)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 231))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_fill_colour) = (NewColour*) Asn1Alloc (sizeof (NewColour));
    CheckAsn1Alloc ((v->new_fill_colour), env);
    BDecNewColourContent (b, tagId1, elmtLen1, (v->new_fill_colour), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -618);
    }


    if (!seqDone)
        longjmp (env, -619);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetFillColourContent */




AsnLen
BEncSetFontRefContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetFontRef *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncNewFontContent (b, (v->new_font));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetFontRefContent */

void
BDecSetFontRefContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetFontRef *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -620);


    if (((tagId1 == MAKE_TAG_ID (CNTX, CONS, 232)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 233))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_font) = (NewFont*) Asn1Alloc (sizeof (NewFont));
    CheckAsn1Alloc ((v->new_font), env);
    BDecNewFontContent (b, tagId1, elmtLen1, (v->new_font), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -621);
    }
    else
        longjmp (env, -622);


    if (!seqDone)
        longjmp (env, -623);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetFontRefContent */




AsnLen
BEncSetLineColourContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetLineColour *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncNewColourContent (b, (v->new_line_colour));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetLineColourContent */

void
BDecSetLineColourContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetLineColour *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -624);


    if (((tagId1 == MAKE_TAG_ID (CNTX, CONS, 230)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 231))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_line_colour) = (NewColour*) Asn1Alloc (sizeof (NewColour));
    CheckAsn1Alloc ((v->new_line_colour), env);
    BDecNewColourContent (b, tagId1, elmtLen1, (v->new_line_colour), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -625);
    }
    else
        longjmp (env, -626);


    if (!seqDone)
        longjmp (env, -627);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetLineColourContent */




AsnLen
BEncSetSpeedContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetSpeed *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncRationalContent (b, (v->new_speed));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetSpeedContent */

void
BDecSetSpeedContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetSpeed *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -628);


    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_speed) = (Rational*) Asn1Alloc (sizeof (Rational));
    CheckAsn1Alloc ((v->new_speed), env);
    BDecRationalContent (b, tagId1, elmtLen1, (v->new_speed), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -629);
    }
    else
        longjmp (env, -630);


    if (!seqDone)
        longjmp (env, -631);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetSpeedContent */




AsnLen
BEncSetTimerContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetTimer *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->new_timer)))
    {
    BEncEocIfNec (b);
    itemLen = BEncNewTimerContent (b, (v->new_timer));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;
    }

    itemLen = BEncGenericIntegerContent (b, (v->timer_id));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetTimerContent */

void
BDecSetTimerContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetTimer *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -632);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->timer_id) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->timer_id), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->timer_id), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -633);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_timer) = (NewTimer*) Asn1Alloc (sizeof (NewTimer));
    CheckAsn1Alloc ((v->new_timer), env);
    BDecNewTimerContent (b, tagId1, elmtLen1, (v->new_timer), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -634);
    }


    if (!seqDone)
        longjmp (env, -635);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetTimerContent */




AsnLen
BEncSetVariableContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetVariable *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncNewVariableValueContent (b, (v->new_variable_value));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetVariableContent */

void
BDecSetVariableContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetVariable *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -636);


    if (((tagId1 == MAKE_TAG_ID (CNTX, CONS, 226)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 225)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 227)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 228)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 229))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_variable_value) = (NewVariableValue*) Asn1Alloc (sizeof (NewVariableValue));
    CheckAsn1Alloc ((v->new_variable_value), env);
    BDecNewVariableValueContent (b, tagId1, elmtLen1, (v->new_variable_value), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -637);
    }
    else
        longjmp (env, -638);


    if (!seqDone)
        longjmp (env, -639);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetVariableContent */




AsnLen
BEncTestVariableContent PARAMS ((b, v),
BUF_TYPE b _AND_
TestVariable *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncComparisonValueContent (b, (v->comparison_value));

    totalLen += itemLen;

    itemLen = BEncGenericIntegerContent (b, (v->operator));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncTestVariableContent */

void
BDecTestVariableContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TestVariable *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -640);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->operator) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->operator), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->operator), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -641);


    if (((tagId1 == MAKE_TAG_ID (CNTX, CONS, 225)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 226)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 227)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 228)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 229))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->comparison_value) = (ComparisonValue*) Asn1Alloc (sizeof (ComparisonValue));
    CheckAsn1Alloc ((v->comparison_value), env);
    BDecComparisonValueContent (b, tagId1, elmtLen1, (v->comparison_value), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -642);
    }
    else
        longjmp (env, -643);


    if (!seqDone)
        longjmp (env, -644);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTestVariableContent */




AsnLen
BEncTransitionToContent PARAMS ((b, v),
BUF_TYPE b _AND_
TransitionTo *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->transition_effect)))
    {
    itemLen = BEncGenericIntegerContent (b, (v->transition_effect));

    totalLen += itemLen;
    }

    itemLen = BEncConnectionTagOrNullContent (b, (v->connection_tag_or_null));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncTransitionToContent */

void
BDecTransitionToContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TransitionTo *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -645);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, NULLTYPE_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->connection_tag_or_null) = (ConnectionTagOrNull*) Asn1Alloc (sizeof (ConnectionTagOrNull));
    CheckAsn1Alloc ((v->connection_tag_or_null), env);
    BDecConnectionTagOrNullContent (b, tagId1, elmtLen1, (v->connection_tag_or_null), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -646);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->transition_effect) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->transition_effect), env);
    BDecGenericIntegerContent (b, tagId1, elmtLen1, (v->transition_effect), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -647);
    }


    if (!seqDone)
        longjmp (env, -648);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTransitionToContent */




AsnLen
BEncSetBackgroundColourContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetBackgroundColour *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncNewColourContent (b, (v->new_background_colour));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetBackgroundColourContent */

void
BDecSetBackgroundColourContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetBackgroundColour *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -649);


    if (((tagId1 == MAKE_TAG_ID (CNTX, CONS, 230)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 231))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_background_colour) = (NewColour*) Asn1Alloc (sizeof (NewColour));
    CheckAsn1Alloc ((v->new_background_colour), env);
    BDecNewColourContent (b, tagId1, elmtLen1, (v->new_background_colour), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -650);
    }
    else
        longjmp (env, -651);


    if (!seqDone)
        longjmp (env, -652);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetBackgroundColourContent */




AsnLen
BEncSetTextColourContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetTextColour *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncNewColourContent (b, (v->new_text_colour));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetTextColourContent */

void
BDecSetTextColourContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetTextColour *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -653);


    if (((tagId1 == MAKE_TAG_ID (CNTX, CONS, 230)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 231))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_text_colour) = (NewColour*) Asn1Alloc (sizeof (NewColour));
    CheckAsn1Alloc ((v->new_text_colour), env);
    BDecNewColourContent (b, tagId1, elmtLen1, (v->new_text_colour), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -654);
    }
    else
        longjmp (env, -655);


    if (!seqDone)
        longjmp (env, -656);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetTextColourContent */


AsnLen
BEncSetDesktopColourContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetDesktopColour *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncNewColourContent (b, (v->new_desktop_colour));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetDesktopColourContent */

void
BDecSetDesktopColourContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetDesktopColour *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -653);


    if (((tagId1 == MAKE_TAG_ID (CNTX, CONS, 230)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 231))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_desktop_colour) = (NewColour*) Asn1Alloc (sizeof (NewColour));
    CheckAsn1Alloc ((v->new_desktop_colour), env);
    BDecNewColourContent (b, tagId1, elmtLen1, (v->new_desktop_colour), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -654);
    }
    else
        longjmp (env, -655);


    if (!seqDone)
        longjmp (env, -656);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetDesktopColourContent */




AsnLen
BEncNewReferencedContentContent PARAMS ((b, v),
BUF_TYPE b _AND_
NewReferencedContent *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->new_content_cache_priority)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGenericIntegerContent (b, (v->new_content_cache_priority));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 235);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncNewContentSizeContent (b, (v->new_content_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 234);

    totalLen += itemLen;

    itemLen = BEncGenericContentReferenceContent (b, (v->generic_content_reference));

    totalLen += itemLen;

    return totalLen;

}  /* BEncNewReferencedContentContent */

void
BDecNewReferencedContentContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NewReferencedContent *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (CNTX, PRIM, 69)) ||
(tagId1 == MAKE_TAG_ID (CNTX, CONS, 69)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->generic_content_reference) = (GenericContentReference*) Asn1Alloc (sizeof (GenericContentReference));
    CheckAsn1Alloc ((v->generic_content_reference), env);
    BDecGenericContentReferenceContent (b, tagId1, elmtLen1, (v->generic_content_reference), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -657);


    if (((tagId1 == MAKE_TAG_ID (CNTX, CONS, 234))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_content_size) = (NewContentSize*) Asn1Alloc (sizeof (NewContentSize));
    CheckAsn1Alloc ((v->new_content_size), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecNewContentSizeContent (b, tagId2, elmtLen2, (v->new_content_size), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -658);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (CNTX, CONS, 235))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_content_cache_priority) = (GenericInteger*) Asn1Alloc (sizeof (GenericInteger));
    CheckAsn1Alloc ((v->new_content_cache_priority), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericIntegerContent (b, tagId2, elmtLen2, (v->new_content_cache_priority), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -659);
    }


    if (!seqDone)
        longjmp (env, -660);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNewReferencedContentContent */




AsnLen
BEncStreamClassSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
StreamClassSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncStreamComponentContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncStreamClassSeqOfContent */

void
BDecStreamClassSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
StreamClassSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        StreamComponent **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (StreamComponent**) AsnListAppend (v);
    (*tmpVar) = (StreamComponent*) Asn1Alloc (sizeof (StreamComponent));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecStreamComponentContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecStreamClassSeqOfContent */




AsnLen
BEncApplicationClassSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
ApplicationClassSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncDefaultAttributeContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncApplicationClassSeqOfContent */

void
BDecApplicationClassSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ApplicationClassSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        DefaultAttribute **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (DefaultAttribute**) AsnListAppend (v);
    (*tmpVar) = (DefaultAttribute*) Asn1Alloc (sizeof (DefaultAttribute));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecDefaultAttributeContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecApplicationClassSeqOfContent */




AsnLen
BEncStreamClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
StreamClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->looping)))
    {
    itemLen = BEncStreamClassIntContent (b, (v->looping));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 94);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->storage)))
    {
    itemLen = BEncStorageContent (b, (v->storage));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 93);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->multiplex)))
    {
    BEncEocIfNec (b);
    itemLen = BEncStreamClassSeqOfContent (b, (v->multiplex));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 92);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncStreamClassContent */

void
BDecStreamClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
StreamClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 92):
    (v->multiplex) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->multiplex), env);
    BDecStreamClassSeqOfContent (b, tagId1, elmtLen1, (v->multiplex), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 93):
    (v->storage) = (Storage*) Asn1Alloc (sizeof (Storage));
    CheckAsn1Alloc ((v->storage), env);
    BDecStorageContent (b, tagId1, elmtLen1, (v->storage), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 94):
    (v->looping) = (StreamClassInt*) Asn1Alloc (sizeof (StreamClassInt));
    CheckAsn1Alloc ((v->looping), env);
    BDecStreamClassIntContent (b, tagId1, elmtLen1, (v->looping), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecStreamClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -661);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 1)
    {
        Asn1Error ("BDecStreamClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -662);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecStreamClassContent */




AsnLen
BEncNewContentContent PARAMS ((b, v),
BUF_TYPE b _AND_
NewContent *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case NEWCONTENT_NEW_INCLUDED_CONTENT:
    itemLen = BEncGenericOctetStringContent (b, (v->a.new_included_content));

    totalLen += itemLen;

    break;

       case NEWCONTENT_NEW_REFERENCED_CONTENT:
    BEncEocIfNec (b);
    itemLen = BEncNewReferencedContentContent (b, (v->a.new_referenced_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncNewContentContent */

void
BDecNewContentContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
NewContent *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE):
       case MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE):
       case MAKE_TAG_ID (CNTX, CONS, 236):
        (v->choiceId) = NEWCONTENT_NEW_INCLUDED_CONTENT;
    (v->a.new_included_content) = (GenericOctetString*) Asn1Alloc (sizeof (GenericOctetString));
    CheckAsn1Alloc ((v->a.new_included_content), env);
    BDecGenericOctetStringContent (b, tagId0, elmtLen0, (v->a.new_included_content), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
        (v->choiceId) = NEWCONTENT_NEW_REFERENCED_CONTENT;
    (v->a.new_referenced_content) = (NewReferencedContent*) Asn1Alloc (sizeof (NewReferencedContent));
    CheckAsn1Alloc ((v->a.new_referenced_content), env);
    BDecNewReferencedContentContent (b, tagId0, elmtLen0, (v->a.new_referenced_content), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -663);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecNewContentContent */




AsnLen
BEncSetDataContent PARAMS ((b, v),
BUF_TYPE b _AND_
SetData *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    itemLen = BEncNewContentContent (b, (v->new_content));

    totalLen += itemLen;

    itemLen = BEncGenericObjectReferenceContent (b, (v->target));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSetDataContent */

void
BDecSetDataContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SetData *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->target) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->target), env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->target), &totalElmtsLen1, env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    }
    else
        longjmp (env, -664);


    if (((tagId1 == MAKE_TAG_ID (UNIV, PRIM, OCTETSTRING_TAG_CODE)) ||
(tagId1 == MAKE_TAG_ID (UNIV, CONS, OCTETSTRING_TAG_CODE)) ||
    (tagId1 == MAKE_TAG_ID (CNTX, CONS, 236)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->new_content) = (NewContent*) Asn1Alloc (sizeof (NewContent));
    CheckAsn1Alloc ((v->new_content), env);
    BDecNewContentContent (b, tagId1, elmtLen1, (v->new_content), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -665);
    }
    else
        longjmp (env, -666);


    if (!seqDone)
        longjmp (env, -667);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSetDataContent */




AsnLen
BEncElementaryActionContent PARAMS ((b, v),
BUF_TYPE b _AND_
ElementaryAction *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case ELEMENTARYACTION_ACTIVATE:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.activate));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 115);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_ADD:
    BEncEocIfNec (b);
    itemLen = BEncAddContent (b, (v->a.add));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 116);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_ADD_ITEM:
    BEncEocIfNec (b);
    itemLen = BEncAddItemContent (b, (v->a.add_item));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 117);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_APPEND:
    BEncEocIfNec (b);
    itemLen = BEncAppendContent (b, (v->a.append));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 118);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_BRING_TO_FRONT:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.bring_to_front));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 119);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_CALL:
    BEncEocIfNec (b);
    itemLen = BEncCallContent (b, (v->a.call));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 120);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_CALL_ACTION_SLOT:
    BEncEocIfNec (b);
    itemLen = BEncCallActionSlotContent (b, (v->a.call_action_slot));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 121);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_CLEAR:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.clear));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 122);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_CLONE:
    BEncEocIfNec (b);
    itemLen = BEncCloneContent (b, (v->a.clone));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 123);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_CLOSE_CONNECTION:
    BEncEocIfNec (b);
    itemLen = BEncCloseConnectionContent (b, (v->a.close_connection));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 124);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DEACTIVATE:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.deactivate));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 125);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DEL_ITEM:
    BEncEocIfNec (b);
    itemLen = BEncDelItemContent (b, (v->a.del_item));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 126);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DESELECT:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.deselect));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 127);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DESELECT_ITEM:
    BEncEocIfNec (b);
    itemLen = BEncDeselectItemContent (b, (v->a.deselect_item));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 128);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DIVIDE:
    BEncEocIfNec (b);
    itemLen = BEncDivideContent (b, (v->a.divide));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 129);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DRAW_ARC:
    BEncEocIfNec (b);
    itemLen = BEncDrawArcContent (b, (v->a.draw_arc));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 130);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DRAW_LINE:
    BEncEocIfNec (b);
    itemLen = BEncDrawLineContent (b, (v->a.draw_line));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 131);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DRAW_OVAL:
    BEncEocIfNec (b);
    itemLen = BEncDrawOvalContent (b, (v->a.draw_oval));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 132);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DRAW_POLYGON:
    BEncEocIfNec (b);
    itemLen = BEncDrawPolygonContent (b, (v->a.draw_polygon));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 133);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DRAW_POLYLINE:
    BEncEocIfNec (b);
    itemLen = BEncDrawPolylineContent (b, (v->a.draw_polyline));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 134);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DRAW_RECTANGLE:
    BEncEocIfNec (b);
    itemLen = BEncDrawRectangleContent (b, (v->a.draw_rectangle));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 135);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_DRAW_SECTOR:
    BEncEocIfNec (b);
    itemLen = BEncDrawSectorContent (b, (v->a.draw_sector));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 136);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_FORK:
    BEncEocIfNec (b);
    itemLen = BEncForkContent (b, (v->a.fork));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 137);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_AVAILABILITY_STATUS:
    BEncEocIfNec (b);
    itemLen = BEncGetAvailabilityStatusContent (b, (v->a.get_availability_status));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 138);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_BOX_SIZE:
    BEncEocIfNec (b);
    itemLen = BEncGetBoxSizeContent (b, (v->a.get_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 139);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_CELL_ITEM:
    BEncEocIfNec (b);
    itemLen = BEncGetCellItemContent (b, (v->a.get_cell_item));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 140);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_CURSOR_POSITION:
    BEncEocIfNec (b);
    itemLen = BEncGetCursorPositionContent (b, (v->a.get_cursor_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 141);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_ENGINE_SUPPORT:
    BEncEocIfNec (b);
    itemLen = BEncGetEngineSupportContent (b, (v->a.get_engine_support));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 142);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_ENTRY_POINT:
    BEncEocIfNec (b);
    itemLen = BEncGetEntryPointContent (b, (v->a.get_entry_point));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 143);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_FILL_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncGetFillColourContent (b, (v->a.get_fill_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 144);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_FIRST_ITEM:
    BEncEocIfNec (b);
    itemLen = BEncGetFirstItemContent (b, (v->a.get_first_item));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 145);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_HIGHLIGHT_STATUS:
    BEncEocIfNec (b);
    itemLen = BEncGetHighlightStatusContent (b, (v->a.get_highlight_status));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 146);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_INTERACTION_STATUS:
    BEncEocIfNec (b);
    itemLen = BEncGetInteractionStatusContent (b, (v->a.get_interaction_status));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 147);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_ITEM_STATUS:
    BEncEocIfNec (b);
    itemLen = BEncGetItemStatusContent (b, (v->a.get_item_status));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 148);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_LABEL:
    BEncEocIfNec (b);
    itemLen = BEncGetLabelContent (b, (v->a.get_label));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 149);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_LAST_ANCHOR_FIRED:
    BEncEocIfNec (b);
    itemLen = BEncGetLastAnchorFiredContent (b, (v->a.get_last_anchor_fired));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 150);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_LINE_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncGetLineColourContent (b, (v->a.get_line_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 151);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_LINE_STYLE:
    BEncEocIfNec (b);
    itemLen = BEncGetLineStyleContent (b, (v->a.get_line_style));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 152);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_LINE_WIDTH:
    BEncEocIfNec (b);
    itemLen = BEncGetLineWidthContent (b, (v->a.get_line_width));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 153);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_LIST_ITEM:
    BEncEocIfNec (b);
    itemLen = BEncGetListItemContent (b, (v->a.get_list_item));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 154);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_LIST_SIZE:
    BEncEocIfNec (b);
    itemLen = BEncGetListSizeContent (b, (v->a.get_list_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 155);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_OVERWRITE_MODE:
    BEncEocIfNec (b);
    itemLen = BEncGetOverwriteModeContent (b, (v->a.get_overwrite_mode));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 156);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_PORTION:
    BEncEocIfNec (b);
    itemLen = BEncGetPortionContent (b, (v->a.get_portion));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 157);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_POSITION:
    BEncEocIfNec (b);
    itemLen = BEncGetPositionContent (b, (v->a.get_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 158);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_RUNNING_STATUS:
    BEncEocIfNec (b);
    itemLen = BEncGetRunningStatusContent (b, (v->a.get_running_status));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 159);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_SELECTION_STATUS:
    BEncEocIfNec (b);
    itemLen = BEncGetSelectionStatusContent (b, (v->a.get_selection_status));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 160);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_SLIDER_VALUE:
    BEncEocIfNec (b);
    itemLen = BEncGetSliderValueContent (b, (v->a.get_slider_value));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 161);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_TEXT_CONTENT:
    BEncEocIfNec (b);
    itemLen = BEncGetTextContentContent (b, (v->a.get_text_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 162);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_TEXT_DATA:
    BEncEocIfNec (b);
    itemLen = BEncGetTextDataContent (b, (v->a.get_text_data));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 163);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_TOKEN_POSITION:
    BEncEocIfNec (b);
    itemLen = BEncGetTokenPositionContent (b, (v->a.get_token_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 164);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_VOLUME:
    BEncEocIfNec (b);
    itemLen = BEncGetVolumeContent (b, (v->a.get_volume));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 165);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_LAUNCH:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.launch));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 166);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_LOCK_SCREEN:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.lock_screen));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 167);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_MODULO:
    BEncEocIfNec (b);
    itemLen = BEncModuloContent (b, (v->a.modulo));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 168);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_MOVE:
    BEncEocIfNec (b);
    itemLen = BEncMoveContent (b, (v->a.move));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 169);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_MOVE_TO:
    BEncEocIfNec (b);
    itemLen = BEncMoveToContent (b, (v->a.move_to));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 170);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_MULTIPLY:
    BEncEocIfNec (b);
    itemLen = BEncMultiplyContent (b, (v->a.multiply));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 171);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_OPEN_CONNECTION:
    BEncEocIfNec (b);
    itemLen = BEncOpenConnectionContent (b, (v->a.open_connection));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 172);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_PRELOAD:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.preload));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 173);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_PUT_BEFORE:
    BEncEocIfNec (b);
    itemLen = BEncPutBeforeContent (b, (v->a.put_before));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 174);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_PUT_BEHIND:
    BEncEocIfNec (b);
    itemLen = BEncPutBehindContent (b, (v->a.put_behind));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 175);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_QUIT:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.quit));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 176);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_READ_PERSISTENT:
    BEncEocIfNec (b);
    itemLen = BEncReadPersistentContent (b, (v->a.read_persistent));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 177);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_RUN:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.run));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 178);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SCALE_BITMAP:
    BEncEocIfNec (b);
    itemLen = BEncScaleBitmapContent (b, (v->a.scale_bitmap));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 179);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SCALE_VIDEO:
    BEncEocIfNec (b);
    itemLen = BEncScaleVideoContent (b, (v->a.scale_video));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 180);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SCROLL_ITEMS:
    BEncEocIfNec (b);
    itemLen = BEncScrollItemsContent (b, (v->a.scroll_items));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 181);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SELECT:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.select));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 182);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SELECT_ITEM:
    BEncEocIfNec (b);
    itemLen = BEncSelectItemContent (b, (v->a.select_item));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 183);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SEND_EVENT:
    BEncEocIfNec (b);
    itemLen = BEncSendEventContent (b, (v->a.send_event));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 184);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SEND_TO_BACK:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.send_to_back));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 185);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_BOX_SIZE:
    BEncEocIfNec (b);
    itemLen = BEncSetBoxSizeContent (b, (v->a.set_box_size));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 186);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_CACHE_PRIORITY:
    BEncEocIfNec (b);
    itemLen = BEncSetCachePriorityContent (b, (v->a.set_cache_priority));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 187);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_COUNTER_END_POSITION:
    BEncEocIfNec (b);
    itemLen = BEncSetCounterEndPositionContent (b, (v->a.set_counter_end_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 188);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_COUNTER_POSITION:
    BEncEocIfNec (b);
    itemLen = BEncSetCounterPositionContent (b, (v->a.set_counter_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 189);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_COUNTER_TRIGGER:
    BEncEocIfNec (b);
    itemLen = BEncSetCounterTriggerContent (b, (v->a.set_counter_trigger));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 190);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_CURSOR_POSITION:
    BEncEocIfNec (b);
    itemLen = BEncSetCursorPositionContent (b, (v->a.set_cursor_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 191);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_CURSOR_SHAPE:
    BEncEocIfNec (b);
    itemLen = BEncSetCursorShapeContent (b, (v->a.set_cursor_shape));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 192);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_DATA:
    BEncEocIfNec (b);
    itemLen = BEncSetDataContent (b, (v->a.set_data));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 193);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_ENTRY_POINT:
    BEncEocIfNec (b);
    itemLen = BEncSetEntryPointContent (b, (v->a.set_entry_point));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 194);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_FILL_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncSetFillColourContent (b, (v->a.set_fill_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 195);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_FIRST_ITEM:
    BEncEocIfNec (b);
    itemLen = BEncSetFirstItemContent (b, (v->a.set_first_item));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 196);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_FONT_REF:
    BEncEocIfNec (b);
    itemLen = BEncSetFontRefContent (b, (v->a.set_font_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 197);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_HIGHLIGHT_STATUS:
    BEncEocIfNec (b);
    itemLen = BEncSetHighlightStatusContent (b, (v->a.set_highlight_status));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 198);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_INTERACTION_STATUS:
    BEncEocIfNec (b);
    itemLen = BEncSetInteractionStatusContent (b, (v->a.set_interaction_status));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 199);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_LABEL:
    BEncEocIfNec (b);
    itemLen = BEncSetLabelContent (b, (v->a.set_label));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 200);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_LINE_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncSetLineColourContent (b, (v->a.set_line_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 201);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_LINE_STYLE:
    BEncEocIfNec (b);
    itemLen = BEncSetLineStyleContent (b, (v->a.set_line_style));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 202);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_LINE_WIDTH:
    BEncEocIfNec (b);
    itemLen = BEncSetLineWidthContent (b, (v->a.set_line_width));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 203);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_OVERWRITE_MODE:
    BEncEocIfNec (b);
    itemLen = BEncSetOverwriteModeContent (b, (v->a.set_overwrite_mode));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 204);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_PALETTE_REF:
    BEncEocIfNec (b);
    itemLen = BEncSetPaletteRefContent (b, (v->a.set_palette_ref));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 205);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_PORTION:
    BEncEocIfNec (b);
    itemLen = BEncSetPortionContent (b, (v->a.set_portion));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 206);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_POSITION:
    BEncEocIfNec (b);
    itemLen = BEncSetPositionContent (b, (v->a.set_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 207);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_SLIDER_VALUE:
    BEncEocIfNec (b);
    itemLen = BEncSetSliderValueContent (b, (v->a.set_slider_value));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 208);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_SPEED:
    BEncEocIfNec (b);
    itemLen = BEncSetSpeedContent (b, (v->a.set_speed));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 209);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_TIMER:
    BEncEocIfNec (b);
    itemLen = BEncSetTimerContent (b, (v->a.set_timer));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 210);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_TRANSPARENCY:
    BEncEocIfNec (b);
    itemLen = BEncSetTransparencyContent (b, (v->a.set_transparency));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 211);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_VARIABLE:
    BEncEocIfNec (b);
    itemLen = BEncSetVariableContent (b, (v->a.set_variable));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 212);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_VOLUME:
    BEncEocIfNec (b);
    itemLen = BEncSetVolumeContent (b, (v->a.set_volume));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 213);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SPAWN:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.spawn));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 214);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_STEP:
    BEncEocIfNec (b);
    itemLen = BEncStepContent (b, (v->a.step));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 215);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_STOP:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.stop));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 216);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_STORE_PERSISTENT:
    BEncEocIfNec (b);
    itemLen = BEncStorePersistentContent (b, (v->a.store_persistent));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 217);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SUBTRACT:
    BEncEocIfNec (b);
    itemLen = BEncSubtractContent (b, (v->a.subtract));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 218);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_TEST_VARIABLE:
    BEncEocIfNec (b);
    itemLen = BEncTestVariableContent (b, (v->a.test_variable));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 219);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_TOGGLE:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.toggle));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 220);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_TOGGLE_ITEM:
    BEncEocIfNec (b);
    itemLen = BEncToggleItemContent (b, (v->a.toggle_item));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 221);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_TRANSITION_TO:
    BEncEocIfNec (b);
    itemLen = BEncTransitionToContent (b, (v->a.transition_to));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 222);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_UNLOAD:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.unload));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 223);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_UNLOCK_SCREEN:
    BEncEocIfNec (b);
    itemLen = BEncGenericObjectReferenceContent (b, (v->a.unlock_screen));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 224);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_BACKGROUND_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncSetBackgroundColourContent (b, (v->a.set_background_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 237);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_CELL_POSITION:
    BEncEocIfNec (b);
    itemLen = BEncSetCellPositionContent (b, (v->a.set_cell_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 238);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_INPUT_REGISTER:
    BEncEocIfNec (b);
    itemLen = BEncSetInputRegisterContent (b, (v->a.set_input_register));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 239);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_TEXT_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncSetTextColourContent (b, (v->a.set_text_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 240);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_FONT_ATTRIBUTES:
    BEncEocIfNec (b);
    itemLen = BEncSetFontAttributesContent (b, (v->a.set_font_attributes));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 241);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_VIDEO_DECODE_OFFSET:
    BEncEocIfNec (b);
    itemLen = BEncSetPositionOffsetContent (b, (v->a.set_position_offset));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 242);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_VIDEO_DECODE_OFFSET:
    BEncEocIfNec (b);
    itemLen = BEncGetPositionOffsetContent (b, (v->a.get_position_offset));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 243);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_GET_FOCUS_POSITION:
    BEncEocIfNec (b);
    itemLen = BEncGetFocusPositionContent (b, (v->a.get_focus_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 244);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_FOCUS_POSITION:
    BEncEocIfNec (b);
    itemLen = BEncSetFocusPositionContent (b, (v->a.set_focus_position));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 245);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_BITMAP_DECODE_OFFSET:
    BEncEocIfNec (b);
    itemLen = BEncSetPositionOffsetContent (b, (v->a.set_position_offset));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 246);

    totalLen += itemLen;

    break;
    
       case ELEMENTARYACTION_GET_BITMAP_DECODE_OFFSET:
    BEncEocIfNec (b);
    itemLen = BEncGetPositionOffsetContent (b, (v->a.get_position_offset));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 247);

    totalLen += itemLen;

    break;

       case ELEMENTARYACTION_SET_SLIDER_PARAMETERS:
    BEncEocIfNec (b);
    itemLen = BEncSetSliderParametersContent (b, (v->a.set_slider_parameters));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 248);

    totalLen += itemLen;

    break;
    
       case ELEMENTARYACTION_SET_DESKTOP_COLOUR:
    BEncEocIfNec (b);
    itemLen = BEncSetDesktopColourContent (b, (v->a.set_desktop_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 250);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncElementaryActionContent */

void
BDecElementaryActionContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ElementaryAction *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, CONS, 115):
        (v->choiceId) = ELEMENTARYACTION_ACTIVATE;
    (v->a.activate) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.activate), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.activate), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 116):
        (v->choiceId) = ELEMENTARYACTION_ADD;
    (v->a.add) = (Add*) Asn1Alloc (sizeof (Add));
    CheckAsn1Alloc ((v->a.add), env);
    BDecAddContent (b, tagId0, elmtLen0, (v->a.add), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 117):
        (v->choiceId) = ELEMENTARYACTION_ADD_ITEM;
    (v->a.add_item) = (AddItem*) Asn1Alloc (sizeof (AddItem));
    CheckAsn1Alloc ((v->a.add_item), env);
    BDecAddItemContent (b, tagId0, elmtLen0, (v->a.add_item), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 118):
        (v->choiceId) = ELEMENTARYACTION_APPEND;
    (v->a.append) = (Append*) Asn1Alloc (sizeof (Append));
    CheckAsn1Alloc ((v->a.append), env);
    BDecAppendContent (b, tagId0, elmtLen0, (v->a.append), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 119):
        (v->choiceId) = ELEMENTARYACTION_BRING_TO_FRONT;
    (v->a.bring_to_front) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.bring_to_front), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.bring_to_front), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 120):
        (v->choiceId) = ELEMENTARYACTION_CALL;
    (v->a.call) = (Call*) Asn1Alloc (sizeof (Call));
    CheckAsn1Alloc ((v->a.call), env);
    BDecCallContent (b, tagId0, elmtLen0, (v->a.call), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 121):
        (v->choiceId) = ELEMENTARYACTION_CALL_ACTION_SLOT;
    (v->a.call_action_slot) = (CallActionSlot*) Asn1Alloc (sizeof (CallActionSlot));
    CheckAsn1Alloc ((v->a.call_action_slot), env);
    BDecCallActionSlotContent (b, tagId0, elmtLen0, (v->a.call_action_slot), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 122):
        (v->choiceId) = ELEMENTARYACTION_CLEAR;
    (v->a.clear) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.clear), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.clear), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 123):
        (v->choiceId) = ELEMENTARYACTION_CLONE;
    (v->a.clone) = (Clone*) Asn1Alloc (sizeof (Clone));
    CheckAsn1Alloc ((v->a.clone), env);
    BDecCloneContent (b, tagId0, elmtLen0, (v->a.clone), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 124):
        (v->choiceId) = ELEMENTARYACTION_CLOSE_CONNECTION;
    (v->a.close_connection) = (CloseConnection*) Asn1Alloc (sizeof (CloseConnection));
    CheckAsn1Alloc ((v->a.close_connection), env);
    BDecCloseConnectionContent (b, tagId0, elmtLen0, (v->a.close_connection), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 125):
        (v->choiceId) = ELEMENTARYACTION_DEACTIVATE;
    (v->a.deactivate) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.deactivate), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.deactivate), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 126):
        (v->choiceId) = ELEMENTARYACTION_DEL_ITEM;
    (v->a.del_item) = (DelItem*) Asn1Alloc (sizeof (DelItem));
    CheckAsn1Alloc ((v->a.del_item), env);
    BDecDelItemContent (b, tagId0, elmtLen0, (v->a.del_item), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 127):
        (v->choiceId) = ELEMENTARYACTION_DESELECT;
    (v->a.deselect) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.deselect), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.deselect), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 128):
        (v->choiceId) = ELEMENTARYACTION_DESELECT_ITEM;
    (v->a.deselect_item) = (DeselectItem*) Asn1Alloc (sizeof (DeselectItem));
    CheckAsn1Alloc ((v->a.deselect_item), env);
    BDecDeselectItemContent (b, tagId0, elmtLen0, (v->a.deselect_item), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 129):
        (v->choiceId) = ELEMENTARYACTION_DIVIDE;
    (v->a.divide) = (Divide*) Asn1Alloc (sizeof (Divide));
    CheckAsn1Alloc ((v->a.divide), env);
    BDecDivideContent (b, tagId0, elmtLen0, (v->a.divide), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 130):
        (v->choiceId) = ELEMENTARYACTION_DRAW_ARC;
    (v->a.draw_arc) = (DrawArc*) Asn1Alloc (sizeof (DrawArc));
    CheckAsn1Alloc ((v->a.draw_arc), env);
    BDecDrawArcContent (b, tagId0, elmtLen0, (v->a.draw_arc), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 131):
        (v->choiceId) = ELEMENTARYACTION_DRAW_LINE;
    (v->a.draw_line) = (DrawLine*) Asn1Alloc (sizeof (DrawLine));
    CheckAsn1Alloc ((v->a.draw_line), env);
    BDecDrawLineContent (b, tagId0, elmtLen0, (v->a.draw_line), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 132):
        (v->choiceId) = ELEMENTARYACTION_DRAW_OVAL;
    (v->a.draw_oval) = (DrawOval*) Asn1Alloc (sizeof (DrawOval));
    CheckAsn1Alloc ((v->a.draw_oval), env);
    BDecDrawOvalContent (b, tagId0, elmtLen0, (v->a.draw_oval), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 133):
        (v->choiceId) = ELEMENTARYACTION_DRAW_POLYGON;
    (v->a.draw_polygon) = (DrawPolygon*) Asn1Alloc (sizeof (DrawPolygon));
    CheckAsn1Alloc ((v->a.draw_polygon), env);
    BDecDrawPolygonContent (b, tagId0, elmtLen0, (v->a.draw_polygon), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 134):
        (v->choiceId) = ELEMENTARYACTION_DRAW_POLYLINE;
    (v->a.draw_polyline) = (DrawPolyline*) Asn1Alloc (sizeof (DrawPolyline));
    CheckAsn1Alloc ((v->a.draw_polyline), env);
    BDecDrawPolylineContent (b, tagId0, elmtLen0, (v->a.draw_polyline), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 135):
        (v->choiceId) = ELEMENTARYACTION_DRAW_RECTANGLE;
    (v->a.draw_rectangle) = (DrawRectangle*) Asn1Alloc (sizeof (DrawRectangle));
    CheckAsn1Alloc ((v->a.draw_rectangle), env);
    BDecDrawRectangleContent (b, tagId0, elmtLen0, (v->a.draw_rectangle), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 136):
        (v->choiceId) = ELEMENTARYACTION_DRAW_SECTOR;
    (v->a.draw_sector) = (DrawSector*) Asn1Alloc (sizeof (DrawSector));
    CheckAsn1Alloc ((v->a.draw_sector), env);
    BDecDrawSectorContent (b, tagId0, elmtLen0, (v->a.draw_sector), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 137):
        (v->choiceId) = ELEMENTARYACTION_FORK;
    (v->a.fork) = (Fork*) Asn1Alloc (sizeof (Fork));
    CheckAsn1Alloc ((v->a.fork), env);
    BDecForkContent (b, tagId0, elmtLen0, (v->a.fork), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 138):
        (v->choiceId) = ELEMENTARYACTION_GET_AVAILABILITY_STATUS;
    (v->a.get_availability_status) = (GetAvailabilityStatus*) Asn1Alloc (sizeof (GetAvailabilityStatus));
    CheckAsn1Alloc ((v->a.get_availability_status), env);
    BDecGetAvailabilityStatusContent (b, tagId0, elmtLen0, (v->a.get_availability_status), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 139):
        (v->choiceId) = ELEMENTARYACTION_GET_BOX_SIZE;
    (v->a.get_box_size) = (GetBoxSize*) Asn1Alloc (sizeof (GetBoxSize));
    CheckAsn1Alloc ((v->a.get_box_size), env);
    BDecGetBoxSizeContent (b, tagId0, elmtLen0, (v->a.get_box_size), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 140):
        (v->choiceId) = ELEMENTARYACTION_GET_CELL_ITEM;
    (v->a.get_cell_item) = (GetCellItem*) Asn1Alloc (sizeof (GetCellItem));
    CheckAsn1Alloc ((v->a.get_cell_item), env);
    BDecGetCellItemContent (b, tagId0, elmtLen0, (v->a.get_cell_item), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 141):
        (v->choiceId) = ELEMENTARYACTION_GET_CURSOR_POSITION;
    (v->a.get_cursor_position) = (GetCursorPosition*) Asn1Alloc (sizeof (GetCursorPosition));
    CheckAsn1Alloc ((v->a.get_cursor_position), env);
    BDecGetCursorPositionContent (b, tagId0, elmtLen0, (v->a.get_cursor_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 142):
        (v->choiceId) = ELEMENTARYACTION_GET_ENGINE_SUPPORT;
    (v->a.get_engine_support) = (GetEngineSupport*) Asn1Alloc (sizeof (GetEngineSupport));
    CheckAsn1Alloc ((v->a.get_engine_support), env);
    BDecGetEngineSupportContent (b, tagId0, elmtLen0, (v->a.get_engine_support), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 143):
        (v->choiceId) = ELEMENTARYACTION_GET_ENTRY_POINT;
    (v->a.get_entry_point) = (GetEntryPoint*) Asn1Alloc (sizeof (GetEntryPoint));
    CheckAsn1Alloc ((v->a.get_entry_point), env);
    BDecGetEntryPointContent (b, tagId0, elmtLen0, (v->a.get_entry_point), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 144):
        (v->choiceId) = ELEMENTARYACTION_GET_FILL_COLOUR;
    (v->a.get_fill_colour) = (GetFillColour*) Asn1Alloc (sizeof (GetFillColour));
    CheckAsn1Alloc ((v->a.get_fill_colour), env);
    BDecGetFillColourContent (b, tagId0, elmtLen0, (v->a.get_fill_colour), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 145):
        (v->choiceId) = ELEMENTARYACTION_GET_FIRST_ITEM;
    (v->a.get_first_item) = (GetFirstItem*) Asn1Alloc (sizeof (GetFirstItem));
    CheckAsn1Alloc ((v->a.get_first_item), env);
    BDecGetFirstItemContent (b, tagId0, elmtLen0, (v->a.get_first_item), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 146):
        (v->choiceId) = ELEMENTARYACTION_GET_HIGHLIGHT_STATUS;
    (v->a.get_highlight_status) = (GetHighlightStatus*) Asn1Alloc (sizeof (GetHighlightStatus));
    CheckAsn1Alloc ((v->a.get_highlight_status), env);
    BDecGetHighlightStatusContent (b, tagId0, elmtLen0, (v->a.get_highlight_status), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 147):
        (v->choiceId) = ELEMENTARYACTION_GET_INTERACTION_STATUS;
    (v->a.get_interaction_status) = (GetInteractionStatus*) Asn1Alloc (sizeof (GetInteractionStatus));
    CheckAsn1Alloc ((v->a.get_interaction_status), env);
    BDecGetInteractionStatusContent (b, tagId0, elmtLen0, (v->a.get_interaction_status), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 148):
        (v->choiceId) = ELEMENTARYACTION_GET_ITEM_STATUS;
    (v->a.get_item_status) = (GetItemStatus*) Asn1Alloc (sizeof (GetItemStatus));
    CheckAsn1Alloc ((v->a.get_item_status), env);
    BDecGetItemStatusContent (b, tagId0, elmtLen0, (v->a.get_item_status), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 149):
        (v->choiceId) = ELEMENTARYACTION_GET_LABEL;
    (v->a.get_label) = (GetLabel*) Asn1Alloc (sizeof (GetLabel));
    CheckAsn1Alloc ((v->a.get_label), env);
    BDecGetLabelContent (b, tagId0, elmtLen0, (v->a.get_label), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 150):
        (v->choiceId) = ELEMENTARYACTION_GET_LAST_ANCHOR_FIRED;
    (v->a.get_last_anchor_fired) = (GetLastAnchorFired*) Asn1Alloc (sizeof (GetLastAnchorFired));
    CheckAsn1Alloc ((v->a.get_last_anchor_fired), env);
    BDecGetLastAnchorFiredContent (b, tagId0, elmtLen0, (v->a.get_last_anchor_fired), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 151):
        (v->choiceId) = ELEMENTARYACTION_GET_LINE_COLOUR;
    (v->a.get_line_colour) = (GetLineColour*) Asn1Alloc (sizeof (GetLineColour));
    CheckAsn1Alloc ((v->a.get_line_colour), env);
    BDecGetLineColourContent (b, tagId0, elmtLen0, (v->a.get_line_colour), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 152):
        (v->choiceId) = ELEMENTARYACTION_GET_LINE_STYLE;
    (v->a.get_line_style) = (GetLineStyle*) Asn1Alloc (sizeof (GetLineStyle));
    CheckAsn1Alloc ((v->a.get_line_style), env);
    BDecGetLineStyleContent (b, tagId0, elmtLen0, (v->a.get_line_style), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 153):
        (v->choiceId) = ELEMENTARYACTION_GET_LINE_WIDTH;
    (v->a.get_line_width) = (GetLineWidth*) Asn1Alloc (sizeof (GetLineWidth));
    CheckAsn1Alloc ((v->a.get_line_width), env);
    BDecGetLineWidthContent (b, tagId0, elmtLen0, (v->a.get_line_width), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 154):
        (v->choiceId) = ELEMENTARYACTION_GET_LIST_ITEM;
    (v->a.get_list_item) = (GetListItem*) Asn1Alloc (sizeof (GetListItem));
    CheckAsn1Alloc ((v->a.get_list_item), env);
    BDecGetListItemContent (b, tagId0, elmtLen0, (v->a.get_list_item), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 155):
        (v->choiceId) = ELEMENTARYACTION_GET_LIST_SIZE;
    (v->a.get_list_size) = (GetListSize*) Asn1Alloc (sizeof (GetListSize));
    CheckAsn1Alloc ((v->a.get_list_size), env);
    BDecGetListSizeContent (b, tagId0, elmtLen0, (v->a.get_list_size), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 156):
        (v->choiceId) = ELEMENTARYACTION_GET_OVERWRITE_MODE;
    (v->a.get_overwrite_mode) = (GetOverwriteMode*) Asn1Alloc (sizeof (GetOverwriteMode));
    CheckAsn1Alloc ((v->a.get_overwrite_mode), env);
    BDecGetOverwriteModeContent (b, tagId0, elmtLen0, (v->a.get_overwrite_mode), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 157):
        (v->choiceId) = ELEMENTARYACTION_GET_PORTION;
    (v->a.get_portion) = (GetPortion*) Asn1Alloc (sizeof (GetPortion));
    CheckAsn1Alloc ((v->a.get_portion), env);
    BDecGetPortionContent (b, tagId0, elmtLen0, (v->a.get_portion), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 158):
        (v->choiceId) = ELEMENTARYACTION_GET_POSITION;
    (v->a.get_position) = (GetPosition*) Asn1Alloc (sizeof (GetPosition));
    CheckAsn1Alloc ((v->a.get_position), env);
    BDecGetPositionContent (b, tagId0, elmtLen0, (v->a.get_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 159):
        (v->choiceId) = ELEMENTARYACTION_GET_RUNNING_STATUS;
    (v->a.get_running_status) = (GetRunningStatus*) Asn1Alloc (sizeof (GetRunningStatus));
    CheckAsn1Alloc ((v->a.get_running_status), env);
    BDecGetRunningStatusContent (b, tagId0, elmtLen0, (v->a.get_running_status), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 160):
        (v->choiceId) = ELEMENTARYACTION_GET_SELECTION_STATUS;
    (v->a.get_selection_status) = (GetSelectionStatus*) Asn1Alloc (sizeof (GetSelectionStatus));
    CheckAsn1Alloc ((v->a.get_selection_status), env);
    BDecGetSelectionStatusContent (b, tagId0, elmtLen0, (v->a.get_selection_status), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 161):
        (v->choiceId) = ELEMENTARYACTION_GET_SLIDER_VALUE;
    (v->a.get_slider_value) = (GetSliderValue*) Asn1Alloc (sizeof (GetSliderValue));
    CheckAsn1Alloc ((v->a.get_slider_value), env);
    BDecGetSliderValueContent (b, tagId0, elmtLen0, (v->a.get_slider_value), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 162):
        (v->choiceId) = ELEMENTARYACTION_GET_TEXT_CONTENT;
    (v->a.get_text_content) = (GetTextContent*) Asn1Alloc (sizeof (GetTextContent));
    CheckAsn1Alloc ((v->a.get_text_content), env);
    BDecGetTextContentContent (b, tagId0, elmtLen0, (v->a.get_text_content), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 163):
        (v->choiceId) = ELEMENTARYACTION_GET_TEXT_DATA;
    (v->a.get_text_data) = (GetTextData*) Asn1Alloc (sizeof (GetTextData));
    CheckAsn1Alloc ((v->a.get_text_data), env);
    BDecGetTextDataContent (b, tagId0, elmtLen0, (v->a.get_text_data), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 164):
        (v->choiceId) = ELEMENTARYACTION_GET_TOKEN_POSITION;
    (v->a.get_token_position) = (GetTokenPosition*) Asn1Alloc (sizeof (GetTokenPosition));
    CheckAsn1Alloc ((v->a.get_token_position), env);
    BDecGetTokenPositionContent (b, tagId0, elmtLen0, (v->a.get_token_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 165):
        (v->choiceId) = ELEMENTARYACTION_GET_VOLUME;
    (v->a.get_volume) = (GetVolume*) Asn1Alloc (sizeof (GetVolume));
    CheckAsn1Alloc ((v->a.get_volume), env);
    BDecGetVolumeContent (b, tagId0, elmtLen0, (v->a.get_volume), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 166):
        (v->choiceId) = ELEMENTARYACTION_LAUNCH;
    (v->a.launch) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.launch), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.launch), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 167):
        (v->choiceId) = ELEMENTARYACTION_LOCK_SCREEN;
    (v->a.lock_screen) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.lock_screen), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.lock_screen), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 168):
        (v->choiceId) = ELEMENTARYACTION_MODULO;
    (v->a.modulo) = (Modulo*) Asn1Alloc (sizeof (Modulo));
    CheckAsn1Alloc ((v->a.modulo), env);
    BDecModuloContent (b, tagId0, elmtLen0, (v->a.modulo), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 169):
        (v->choiceId) = ELEMENTARYACTION_MOVE;
    (v->a.move) = (Move*) Asn1Alloc (sizeof (Move));
    CheckAsn1Alloc ((v->a.move), env);
    BDecMoveContent (b, tagId0, elmtLen0, (v->a.move), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 170):
        (v->choiceId) = ELEMENTARYACTION_MOVE_TO;
    (v->a.move_to) = (MoveTo*) Asn1Alloc (sizeof (MoveTo));
    CheckAsn1Alloc ((v->a.move_to), env);
    BDecMoveToContent (b, tagId0, elmtLen0, (v->a.move_to), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 171):
        (v->choiceId) = ELEMENTARYACTION_MULTIPLY;
    (v->a.multiply) = (Multiply*) Asn1Alloc (sizeof (Multiply));
    CheckAsn1Alloc ((v->a.multiply), env);
    BDecMultiplyContent (b, tagId0, elmtLen0, (v->a.multiply), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 172):
        (v->choiceId) = ELEMENTARYACTION_OPEN_CONNECTION;
    (v->a.open_connection) = (OpenConnection*) Asn1Alloc (sizeof (OpenConnection));
    CheckAsn1Alloc ((v->a.open_connection), env);
    BDecOpenConnectionContent (b, tagId0, elmtLen0, (v->a.open_connection), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 173):
        (v->choiceId) = ELEMENTARYACTION_PRELOAD;
    (v->a.preload) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.preload), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.preload), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 174):
        (v->choiceId) = ELEMENTARYACTION_PUT_BEFORE;
    (v->a.put_before) = (PutBefore*) Asn1Alloc (sizeof (PutBefore));
    CheckAsn1Alloc ((v->a.put_before), env);
    BDecPutBeforeContent (b, tagId0, elmtLen0, (v->a.put_before), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 175):
        (v->choiceId) = ELEMENTARYACTION_PUT_BEHIND;
    (v->a.put_behind) = (PutBehind*) Asn1Alloc (sizeof (PutBehind));
    CheckAsn1Alloc ((v->a.put_behind), env);
    BDecPutBehindContent (b, tagId0, elmtLen0, (v->a.put_behind), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 176):
        (v->choiceId) = ELEMENTARYACTION_QUIT;
    (v->a.quit) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.quit), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.quit), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 177):
        (v->choiceId) = ELEMENTARYACTION_READ_PERSISTENT;
    (v->a.read_persistent) = (ReadPersistent*) Asn1Alloc (sizeof (ReadPersistent));
    CheckAsn1Alloc ((v->a.read_persistent), env);
    BDecReadPersistentContent (b, tagId0, elmtLen0, (v->a.read_persistent), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 178):
        (v->choiceId) = ELEMENTARYACTION_RUN;
    (v->a.run) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.run), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.run), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 179):
        (v->choiceId) = ELEMENTARYACTION_SCALE_BITMAP;
    (v->a.scale_bitmap) = (ScaleBitmap*) Asn1Alloc (sizeof (ScaleBitmap));
    CheckAsn1Alloc ((v->a.scale_bitmap), env);
    BDecScaleBitmapContent (b, tagId0, elmtLen0, (v->a.scale_bitmap), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 180):
        (v->choiceId) = ELEMENTARYACTION_SCALE_VIDEO;
    (v->a.scale_video) = (ScaleVideo*) Asn1Alloc (sizeof (ScaleVideo));
    CheckAsn1Alloc ((v->a.scale_video), env);
    BDecScaleVideoContent (b, tagId0, elmtLen0, (v->a.scale_video), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 181):
        (v->choiceId) = ELEMENTARYACTION_SCROLL_ITEMS;
    (v->a.scroll_items) = (ScrollItems*) Asn1Alloc (sizeof (ScrollItems));
    CheckAsn1Alloc ((v->a.scroll_items), env);
    BDecScrollItemsContent (b, tagId0, elmtLen0, (v->a.scroll_items), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 182):
        (v->choiceId) = ELEMENTARYACTION_SELECT;
    (v->a.select) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.select), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.select), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 183):
        (v->choiceId) = ELEMENTARYACTION_SELECT_ITEM;
    (v->a.select_item) = (SelectItem*) Asn1Alloc (sizeof (SelectItem));
    CheckAsn1Alloc ((v->a.select_item), env);
    BDecSelectItemContent (b, tagId0, elmtLen0, (v->a.select_item), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 184):
        (v->choiceId) = ELEMENTARYACTION_SEND_EVENT;
    (v->a.send_event) = (SendEvent*) Asn1Alloc (sizeof (SendEvent));
    CheckAsn1Alloc ((v->a.send_event), env);
    BDecSendEventContent (b, tagId0, elmtLen0, (v->a.send_event), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 185):
        (v->choiceId) = ELEMENTARYACTION_SEND_TO_BACK;
    (v->a.send_to_back) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.send_to_back), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.send_to_back), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 186):
        (v->choiceId) = ELEMENTARYACTION_SET_BOX_SIZE;
    (v->a.set_box_size) = (SetBoxSize*) Asn1Alloc (sizeof (SetBoxSize));
    CheckAsn1Alloc ((v->a.set_box_size), env);
    BDecSetBoxSizeContent (b, tagId0, elmtLen0, (v->a.set_box_size), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 187):
        (v->choiceId) = ELEMENTARYACTION_SET_CACHE_PRIORITY;
    (v->a.set_cache_priority) = (SetCachePriority*) Asn1Alloc (sizeof (SetCachePriority));
    CheckAsn1Alloc ((v->a.set_cache_priority), env);
    BDecSetCachePriorityContent (b, tagId0, elmtLen0, (v->a.set_cache_priority), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 188):
        (v->choiceId) = ELEMENTARYACTION_SET_COUNTER_END_POSITION;
    (v->a.set_counter_end_position) = (SetCounterEndPosition*) Asn1Alloc (sizeof (SetCounterEndPosition));
    CheckAsn1Alloc ((v->a.set_counter_end_position), env);
    BDecSetCounterEndPositionContent (b, tagId0, elmtLen0, (v->a.set_counter_end_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 189):
        (v->choiceId) = ELEMENTARYACTION_SET_COUNTER_POSITION;
    (v->a.set_counter_position) = (SetCounterPosition*) Asn1Alloc (sizeof (SetCounterPosition));
    CheckAsn1Alloc ((v->a.set_counter_position), env);
    BDecSetCounterPositionContent (b, tagId0, elmtLen0, (v->a.set_counter_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 190):
        (v->choiceId) = ELEMENTARYACTION_SET_COUNTER_TRIGGER;
    (v->a.set_counter_trigger) = (SetCounterTrigger*) Asn1Alloc (sizeof (SetCounterTrigger));
    CheckAsn1Alloc ((v->a.set_counter_trigger), env);
    BDecSetCounterTriggerContent (b, tagId0, elmtLen0, (v->a.set_counter_trigger), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 191):
        (v->choiceId) = ELEMENTARYACTION_SET_CURSOR_POSITION;
    (v->a.set_cursor_position) = (SetCursorPosition*) Asn1Alloc (sizeof (SetCursorPosition));
    CheckAsn1Alloc ((v->a.set_cursor_position), env);
    BDecSetCursorPositionContent (b, tagId0, elmtLen0, (v->a.set_cursor_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 192):
        (v->choiceId) = ELEMENTARYACTION_SET_CURSOR_SHAPE;
    (v->a.set_cursor_shape) = (SetCursorShape*) Asn1Alloc (sizeof (SetCursorShape));
    CheckAsn1Alloc ((v->a.set_cursor_shape), env);
    BDecSetCursorShapeContent (b, tagId0, elmtLen0, (v->a.set_cursor_shape), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 193):
        (v->choiceId) = ELEMENTARYACTION_SET_DATA;
    (v->a.set_data) = (SetData*) Asn1Alloc (sizeof (SetData));
    CheckAsn1Alloc ((v->a.set_data), env);
    BDecSetDataContent (b, tagId0, elmtLen0, (v->a.set_data), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 194):
        (v->choiceId) = ELEMENTARYACTION_SET_ENTRY_POINT;
    (v->a.set_entry_point) = (SetEntryPoint*) Asn1Alloc (sizeof (SetEntryPoint));
    CheckAsn1Alloc ((v->a.set_entry_point), env);
    BDecSetEntryPointContent (b, tagId0, elmtLen0, (v->a.set_entry_point), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 195):
        (v->choiceId) = ELEMENTARYACTION_SET_FILL_COLOUR;
    (v->a.set_fill_colour) = (SetFillColour*) Asn1Alloc (sizeof (SetFillColour));
    CheckAsn1Alloc ((v->a.set_fill_colour), env);
    BDecSetFillColourContent (b, tagId0, elmtLen0, (v->a.set_fill_colour), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 196):
        (v->choiceId) = ELEMENTARYACTION_SET_FIRST_ITEM;
    (v->a.set_first_item) = (SetFirstItem*) Asn1Alloc (sizeof (SetFirstItem));
    CheckAsn1Alloc ((v->a.set_first_item), env);
    BDecSetFirstItemContent (b, tagId0, elmtLen0, (v->a.set_first_item), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 197):
        (v->choiceId) = ELEMENTARYACTION_SET_FONT_REF;
    (v->a.set_font_ref) = (SetFontRef*) Asn1Alloc (sizeof (SetFontRef));
    CheckAsn1Alloc ((v->a.set_font_ref), env);
    BDecSetFontRefContent (b, tagId0, elmtLen0, (v->a.set_font_ref), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 198):
        (v->choiceId) = ELEMENTARYACTION_SET_HIGHLIGHT_STATUS;
    (v->a.set_highlight_status) = (SetHighlightStatus*) Asn1Alloc (sizeof (SetHighlightStatus));
    CheckAsn1Alloc ((v->a.set_highlight_status), env);
    BDecSetHighlightStatusContent (b, tagId0, elmtLen0, (v->a.set_highlight_status), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 199):
        (v->choiceId) = ELEMENTARYACTION_SET_INTERACTION_STATUS;
    (v->a.set_interaction_status) = (SetInteractionStatus*) Asn1Alloc (sizeof (SetInteractionStatus));
    CheckAsn1Alloc ((v->a.set_interaction_status), env);
    BDecSetInteractionStatusContent (b, tagId0, elmtLen0, (v->a.set_interaction_status), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 200):
        (v->choiceId) = ELEMENTARYACTION_SET_LABEL;
    (v->a.set_label) = (SetLabel*) Asn1Alloc (sizeof (SetLabel));
    CheckAsn1Alloc ((v->a.set_label), env);
    BDecSetLabelContent (b, tagId0, elmtLen0, (v->a.set_label), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 201):
        (v->choiceId) = ELEMENTARYACTION_SET_LINE_COLOUR;
    (v->a.set_line_colour) = (SetLineColour*) Asn1Alloc (sizeof (SetLineColour));
    CheckAsn1Alloc ((v->a.set_line_colour), env);
    BDecSetLineColourContent (b, tagId0, elmtLen0, (v->a.set_line_colour), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 202):
        (v->choiceId) = ELEMENTARYACTION_SET_LINE_STYLE;
    (v->a.set_line_style) = (SetLineStyle*) Asn1Alloc (sizeof (SetLineStyle));
    CheckAsn1Alloc ((v->a.set_line_style), env);
    BDecSetLineStyleContent (b, tagId0, elmtLen0, (v->a.set_line_style), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 203):
        (v->choiceId) = ELEMENTARYACTION_SET_LINE_WIDTH;
    (v->a.set_line_width) = (SetLineWidth*) Asn1Alloc (sizeof (SetLineWidth));
    CheckAsn1Alloc ((v->a.set_line_width), env);
    BDecSetLineWidthContent (b, tagId0, elmtLen0, (v->a.set_line_width), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 204):
        (v->choiceId) = ELEMENTARYACTION_SET_OVERWRITE_MODE;
    (v->a.set_overwrite_mode) = (SetOverwriteMode*) Asn1Alloc (sizeof (SetOverwriteMode));
    CheckAsn1Alloc ((v->a.set_overwrite_mode), env);
    BDecSetOverwriteModeContent (b, tagId0, elmtLen0, (v->a.set_overwrite_mode), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 205):
        (v->choiceId) = ELEMENTARYACTION_SET_PALETTE_REF;
    (v->a.set_palette_ref) = (SetPaletteRef*) Asn1Alloc (sizeof (SetPaletteRef));
    CheckAsn1Alloc ((v->a.set_palette_ref), env);
    BDecSetPaletteRefContent (b, tagId0, elmtLen0, (v->a.set_palette_ref), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 206):
        (v->choiceId) = ELEMENTARYACTION_SET_PORTION;
    (v->a.set_portion) = (SetPortion*) Asn1Alloc (sizeof (SetPortion));
    CheckAsn1Alloc ((v->a.set_portion), env);
    BDecSetPortionContent (b, tagId0, elmtLen0, (v->a.set_portion), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 207):
        (v->choiceId) = ELEMENTARYACTION_SET_POSITION;
    (v->a.set_position) = (SetPosition*) Asn1Alloc (sizeof (SetPosition));
    CheckAsn1Alloc ((v->a.set_position), env);
    BDecSetPositionContent (b, tagId0, elmtLen0, (v->a.set_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 208):
        (v->choiceId) = ELEMENTARYACTION_SET_SLIDER_VALUE;
    (v->a.set_slider_value) = (SetSliderValue*) Asn1Alloc (sizeof (SetSliderValue));
    CheckAsn1Alloc ((v->a.set_slider_value), env);
    BDecSetSliderValueContent (b, tagId0, elmtLen0, (v->a.set_slider_value), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 209):
        (v->choiceId) = ELEMENTARYACTION_SET_SPEED;
    (v->a.set_speed) = (SetSpeed*) Asn1Alloc (sizeof (SetSpeed));
    CheckAsn1Alloc ((v->a.set_speed), env);
    BDecSetSpeedContent (b, tagId0, elmtLen0, (v->a.set_speed), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 210):
        (v->choiceId) = ELEMENTARYACTION_SET_TIMER;
    (v->a.set_timer) = (SetTimer*) Asn1Alloc (sizeof (SetTimer));
    CheckAsn1Alloc ((v->a.set_timer), env);
    BDecSetTimerContent (b, tagId0, elmtLen0, (v->a.set_timer), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 211):
        (v->choiceId) = ELEMENTARYACTION_SET_TRANSPARENCY;
    (v->a.set_transparency) = (SetTransparency*) Asn1Alloc (sizeof (SetTransparency));
    CheckAsn1Alloc ((v->a.set_transparency), env);
    BDecSetTransparencyContent (b, tagId0, elmtLen0, (v->a.set_transparency), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 212):
        (v->choiceId) = ELEMENTARYACTION_SET_VARIABLE;
    (v->a.set_variable) = (SetVariable*) Asn1Alloc (sizeof (SetVariable));
    CheckAsn1Alloc ((v->a.set_variable), env);
    BDecSetVariableContent (b, tagId0, elmtLen0, (v->a.set_variable), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 213):
        (v->choiceId) = ELEMENTARYACTION_SET_VOLUME;
    (v->a.set_volume) = (SetVolume*) Asn1Alloc (sizeof (SetVolume));
    CheckAsn1Alloc ((v->a.set_volume), env);
    BDecSetVolumeContent (b, tagId0, elmtLen0, (v->a.set_volume), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 214):
        (v->choiceId) = ELEMENTARYACTION_SPAWN;
    (v->a.spawn) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.spawn), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.spawn), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 215):
        (v->choiceId) = ELEMENTARYACTION_STEP;
    (v->a.step) = (Step*) Asn1Alloc (sizeof (Step));
    CheckAsn1Alloc ((v->a.step), env);
    BDecStepContent (b, tagId0, elmtLen0, (v->a.step), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 216):
        (v->choiceId) = ELEMENTARYACTION_STOP;
    (v->a.stop) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.stop), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.stop), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 217):
        (v->choiceId) = ELEMENTARYACTION_STORE_PERSISTENT;
    (v->a.store_persistent) = (StorePersistent*) Asn1Alloc (sizeof (StorePersistent));
    CheckAsn1Alloc ((v->a.store_persistent), env);
    BDecStorePersistentContent (b, tagId0, elmtLen0, (v->a.store_persistent), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 218):
        (v->choiceId) = ELEMENTARYACTION_SUBTRACT;
    (v->a.subtract) = (Subtract*) Asn1Alloc (sizeof (Subtract));
    CheckAsn1Alloc ((v->a.subtract), env);
    BDecSubtractContent (b, tagId0, elmtLen0, (v->a.subtract), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 219):
        (v->choiceId) = ELEMENTARYACTION_TEST_VARIABLE;
    (v->a.test_variable) = (TestVariable*) Asn1Alloc (sizeof (TestVariable));
    CheckAsn1Alloc ((v->a.test_variable), env);
    BDecTestVariableContent (b, tagId0, elmtLen0, (v->a.test_variable), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 220):
        (v->choiceId) = ELEMENTARYACTION_TOGGLE;
    (v->a.toggle) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.toggle), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.toggle), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 221):
        (v->choiceId) = ELEMENTARYACTION_TOGGLE_ITEM;
    (v->a.toggle_item) = (ToggleItem*) Asn1Alloc (sizeof (ToggleItem));
    CheckAsn1Alloc ((v->a.toggle_item), env);
    BDecToggleItemContent (b, tagId0, elmtLen0, (v->a.toggle_item), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 222):
        (v->choiceId) = ELEMENTARYACTION_TRANSITION_TO;
    (v->a.transition_to) = (TransitionTo*) Asn1Alloc (sizeof (TransitionTo));
    CheckAsn1Alloc ((v->a.transition_to), env);
    BDecTransitionToContent (b, tagId0, elmtLen0, (v->a.transition_to), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 223):
        (v->choiceId) = ELEMENTARYACTION_UNLOAD;
    (v->a.unload) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.unload), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.unload), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 224):
        (v->choiceId) = ELEMENTARYACTION_UNLOCK_SCREEN;
    (v->a.unlock_screen) = (GenericObjectReference*) Asn1Alloc (sizeof (GenericObjectReference));
    CheckAsn1Alloc ((v->a.unlock_screen), env);
    tagId1 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    BDecGenericObjectReferenceContent (b, tagId1, elmtLen1, (v->a.unlock_screen), &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen0 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 237):
        (v->choiceId) = ELEMENTARYACTION_SET_BACKGROUND_COLOUR;
    (v->a.set_background_colour) = (SetBackgroundColour*) Asn1Alloc (sizeof (SetBackgroundColour));
    CheckAsn1Alloc ((v->a.set_background_colour), env);
    BDecSetBackgroundColourContent (b, tagId0, elmtLen0, (v->a.set_background_colour), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 238):
        (v->choiceId) = ELEMENTARYACTION_SET_CELL_POSITION;
    (v->a.set_cell_position) = (SetCellPosition*) Asn1Alloc (sizeof (SetCellPosition));
    CheckAsn1Alloc ((v->a.set_cell_position), env);
    BDecSetCellPositionContent (b, tagId0, elmtLen0, (v->a.set_cell_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 239):
        (v->choiceId) = ELEMENTARYACTION_SET_INPUT_REGISTER;
    (v->a.set_input_register) = (SetInputRegister*) Asn1Alloc (sizeof (SetInputRegister));
    CheckAsn1Alloc ((v->a.set_input_register), env);
    BDecSetInputRegisterContent (b, tagId0, elmtLen0, (v->a.set_input_register), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 240):
        (v->choiceId) = ELEMENTARYACTION_SET_TEXT_COLOUR;
    (v->a.set_text_colour) = (SetTextColour*) Asn1Alloc (sizeof (SetTextColour));
    CheckAsn1Alloc ((v->a.set_text_colour), env);
    BDecSetTextColourContent (b, tagId0, elmtLen0, (v->a.set_text_colour), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 241):
        (v->choiceId) = ELEMENTARYACTION_SET_FONT_ATTRIBUTES;
    (v->a.set_font_attributes) = (SetFontAttributes*) Asn1Alloc (sizeof (SetFontAttributes));
    CheckAsn1Alloc ((v->a.set_font_attributes), env);
    BDecSetFontAttributesContent (b, tagId0, elmtLen0, (v->a.set_font_attributes), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 242):
        (v->choiceId) = ELEMENTARYACTION_SET_VIDEO_DECODE_OFFSET;
    (v->a.set_position_offset) = (SetPositionOffset*) Asn1Alloc (sizeof (SetPositionOffset));
    CheckAsn1Alloc ((v->a.set_position_offset), env);
    BDecSetPositionOffsetContent (b, tagId0, elmtLen0, (v->a.set_position_offset), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 243):
        (v->choiceId) = ELEMENTARYACTION_GET_VIDEO_DECODE_OFFSET;
    (v->a.get_position_offset) = (GetPositionOffset*) Asn1Alloc (sizeof (GetPositionOffset));
    CheckAsn1Alloc ((v->a.get_position_offset), env);
    BDecGetPositionOffsetContent (b, tagId0, elmtLen0, (v->a.get_position_offset), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 244):
        (v->choiceId) = ELEMENTARYACTION_GET_FOCUS_POSITION;
    (v->a.get_focus_position) = (GetFocusPosition*) Asn1Alloc (sizeof (GetFocusPosition));
    CheckAsn1Alloc ((v->a.get_focus_position), env);
    BDecGetFocusPositionContent (b, tagId0, elmtLen0, (v->a.get_focus_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 245):
        (v->choiceId) = ELEMENTARYACTION_SET_FOCUS_POSITION;
    (v->a.set_focus_position) = (SetFocusPosition*) Asn1Alloc (sizeof (SetFocusPosition));
    CheckAsn1Alloc ((v->a.set_focus_position), env);
    BDecSetFocusPositionContent (b, tagId0, elmtLen0, (v->a.set_focus_position), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 246):
        (v->choiceId) = ELEMENTARYACTION_SET_BITMAP_DECODE_OFFSET;
    (v->a.set_position_offset) = (SetPositionOffset*) Asn1Alloc (sizeof (SetPositionOffset));
    CheckAsn1Alloc ((v->a.set_position_offset), env);
    BDecSetPositionOffsetContent (b, tagId0, elmtLen0, (v->a.set_position_offset), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 247):
        (v->choiceId) = ELEMENTARYACTION_GET_BITMAP_DECODE_OFFSET;
    (v->a.get_position_offset) = (GetPositionOffset*) Asn1Alloc (sizeof (GetPositionOffset));
    CheckAsn1Alloc ((v->a.get_position_offset), env);
    BDecGetPositionOffsetContent (b, tagId0, elmtLen0, (v->a.get_position_offset), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 248):
        (v->choiceId) = ELEMENTARYACTION_SET_SLIDER_PARAMETERS;
    (v->a.set_slider_parameters) = (SetSliderParameters*) Asn1Alloc (sizeof (SetSliderParameters));
    CheckAsn1Alloc ((v->a.set_slider_parameters), env);
    BDecSetSliderParametersContent (b, tagId0, elmtLen0, (v->a.set_slider_parameters), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 250):
        (v->choiceId) = ELEMENTARYACTION_SET_DESKTOP_COLOUR;
    (v->a.set_desktop_colour) = (SetDesktopColour*) Asn1Alloc (sizeof (SetDesktopColour));
    CheckAsn1Alloc ((v->a.set_desktop_colour), env);
    BDecSetDesktopColourContent (b, tagId0, elmtLen0, (v->a.set_desktop_colour), &totalElmtsLen1, env);
    break;


    default:
        Asn1Error ("ERROR - unexpected tag in EA CHOICE\n");
        longjmp (env, -668);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecElementaryActionContent */




AsnLen
BEncActionClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
ActionClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncElementaryActionContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncActionClassContent */

void
BDecActionClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ActionClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ElementaryAction **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ElementaryAction**) AsnListAppend (v);
    (*tmpVar) = (ElementaryAction*) Asn1Alloc (sizeof (ElementaryAction));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecElementaryActionContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecActionClassContent */




AsnLen
BEncLinkClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
LinkClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    BEncEocIfNec (b);
    itemLen = BEncActionClassContent (b, (v->link_effect));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 63);

    totalLen += itemLen;

    BEncEocIfNec (b);
    itemLen = BEncLinkConditionContent (b, (v->link_condition));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 62);

    totalLen += itemLen;

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncLinkClassContent */

void
BDecLinkClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
LinkClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 62):
    (v->link_condition) = (LinkCondition*) Asn1Alloc (sizeof (LinkCondition));
    CheckAsn1Alloc ((v->link_condition), env);
    BDecLinkConditionContent (b, tagId1, elmtLen1, (v->link_condition), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 63):
    (v->link_effect) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->link_effect), env);
    BDecActionClassContent (b, tagId1, elmtLen1, (v->link_effect), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

    default:
        Asn1Error ("BDecLinkClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -669);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 3)
    {
        Asn1Error ("BDecLinkClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -670);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecLinkClassContent */




AsnLen
BEncActionSlotContent PARAMS ((b, v),
BUF_TYPE b _AND_
ActionSlot *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case ACTIONSLOT_ACTION_CLASS:
    BEncEocIfNec (b);
    itemLen = BEncActionClassContent (b, (v->a.action_class));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;

    break;

       case ACTIONSLOT_NULL:
    itemLen = BEncAsnNullContent (b, (&v->a.null));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, UNIV, PRIM, 5);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncActionSlotContent */

void
BDecActionSlotContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ActionSlot *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
        (v->choiceId) = ACTIONSLOT_ACTION_CLASS;
    (v->a.action_class) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->a.action_class), env);
    BDecActionClassContent (b, tagId0, elmtLen0, (v->a.action_class), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (UNIV, PRIM, NULLTYPE_TAG_CODE):
        (v->choiceId) = ACTIONSLOT_NULL;
    BDecAsnNullContent (b, tagId0, elmtLen0, (&v->a.null), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -671);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecActionSlotContent */




AsnLen
BEncTokenGroupItemSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
TokenGroupItemSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncActionSlotContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTokenGroupItemSeqOfContent */

void
BDecTokenGroupItemSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TokenGroupItemSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ActionSlot **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ActionSlot**) AsnListAppend (v);
    (*tmpVar) = (ActionSlot*) Asn1Alloc (sizeof (ActionSlot));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecActionSlotContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTokenGroupItemSeqOfContent */




AsnLen
BEncTokenGroupClassSeqOf1Content PARAMS ((b, v),
BUF_TYPE b _AND_
TokenGroupClassSeqOf1 *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncActionSlotContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTokenGroupClassSeqOf1Content */

void
BDecTokenGroupClassSeqOf1Content PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TokenGroupClassSeqOf1 *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        ActionSlot **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (ActionSlot**) AsnListAppend (v);
    (*tmpVar) = (ActionSlot*) Asn1Alloc (sizeof (ActionSlot));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecActionSlotContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTokenGroupClassSeqOf1Content */




AsnLen
BEncTokenGroupItemContent PARAMS ((b, v),
BUF_TYPE b _AND_
TokenGroupItem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->action_slots)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTokenGroupItemSeqOfContent (b, (v->action_slots));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

    totalLen += itemLen;
    }

    itemLen = BEncObjectReferenceContent (b, (v->a_visible));

    totalLen += itemLen;

    return totalLen;

}  /* BEncTokenGroupItemContent */

void
BDecTokenGroupItemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TokenGroupItem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if (((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)) ||
     (tagId1 ==MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE))))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->a_visible) = (ObjectReference*) Asn1Alloc (sizeof (ObjectReference));
    CheckAsn1Alloc ((v->a_visible), env);
    BDecObjectReferenceContent (b, tagId1, elmtLen1, (v->a_visible), &totalElmtsLen1, env);
    if ((elmtLen0 != INDEFINITE_LEN) && (totalElmtsLen1 == elmtLen0))
        seqDone = TRUE;
    else
    {
        tagId1 = BDecTag (b, &totalElmtsLen1, env);

         if ((elmtLen0 == INDEFINITE_LEN) && (tagId1 == EOC_TAG_ID))
        {
            BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
            seqDone = TRUE;
        }
    }
    }
    else
        longjmp (env, -672);


    if ((!seqDone) && ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE))))
    {
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    (v->action_slots) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->action_slots), env);
    BDecTokenGroupItemSeqOfContent (b, tagId1, elmtLen1, (v->action_slots), &totalElmtsLen1, env);
        seqDone = TRUE;
        if (elmtLen0 == INDEFINITE_LEN)
            BDecEoc (b, &totalElmtsLen1, env);
        else if (totalElmtsLen1 != elmtLen0)
            longjmp (env, -673);
    }


    if (!seqDone)
        longjmp (env, -674);

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTokenGroupItemContent */




AsnLen
BEncTokenGroupClassSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
TokenGroupClassSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    BEncEocIfNec (b);
    itemLen = BEncTokenGroupItemContent (b, component);
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, UNIV, CONS, 16);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncTokenGroupClassSeqOfContent */

void
BDecTokenGroupClassSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TokenGroupClassSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        TokenGroupItem **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
    if ((tagId1 == MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE)))
    {
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (TokenGroupItem**) AsnListAppend (v);
    (*tmpVar) = (TokenGroupItem*) Asn1Alloc (sizeof (TokenGroupItem));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecTokenGroupItemContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    }  /* end of tag check if */
    else  /* wrong tag */
    {
         Asn1Error ("Unexpected Tag\n");
         longjmp (env, -675);
    }
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTokenGroupClassSeqOfContent */




AsnLen
BEncTokenGroupClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
TokenGroupClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->no_token_action_slots)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTokenGroupClassSeqOf1Content (b, (v->no_token_action_slots));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 72);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->token_group_items)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTokenGroupClassSeqOfContent (b, (v->token_group_items));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 71);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->movement_table)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTokenManagerClassSeqOfContent (b, (v->movement_table));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 70);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncTokenGroupClassContent */

void
BDecTokenGroupClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
TokenGroupClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 70):
    (v->movement_table) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->movement_table), env);
    BDecTokenManagerClassSeqOfContent (b, tagId1, elmtLen1, (v->movement_table), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 71):
    (v->token_group_items) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->token_group_items), env);
    BDecTokenGroupClassSeqOfContent (b, tagId1, elmtLen1, (v->token_group_items), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 72):
    (v->no_token_action_slots) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->no_token_action_slots), env);
    BDecTokenGroupClassSeqOf1Content (b, tagId1, elmtLen1, (v->no_token_action_slots), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecTokenGroupClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -676);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 1)
    {
        Asn1Error ("BDecTokenGroupClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -677);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecTokenGroupClassContent */




AsnLen
BEncListGroupClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
ListGroupClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->multiple_selection)))
    {
    itemLen = BEncAsnBoolContent (b, (v->multiple_selection));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 75);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->wrap_around)))
    {
    itemLen = BEncAsnBoolContent (b, (v->wrap_around));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 74);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncListGroupClassSeqOfContent (b, (v->positions));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 73);

    totalLen += itemLen;

    if (NOT_NULL ((v->no_token_action_slots)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTokenGroupClassSeqOf1Content (b, (v->no_token_action_slots));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 72);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->token_group_items)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTokenGroupClassSeqOfContent (b, (v->token_group_items));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 71);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->movement_table)))
    {
    BEncEocIfNec (b);
    itemLen = BEncTokenManagerClassSeqOfContent (b, (v->movement_table));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 70);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->shared)))
    {
    itemLen = BEncAsnBoolContent (b, (v->shared));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 59);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_content)))
    {
    BEncEocIfNec (b);
    itemLen = BEncContentBodyContent (b, (v->original_content));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 58);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->content_hook)))
    {
    itemLen = BEncAsnIntContent (b, (v->content_hook));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 57);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->initially_active)))
    {
    itemLen = BEncAsnBoolContent (b, (v->initially_active));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 56);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncListGroupClassContent */

void
BDecListGroupClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ListGroupClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 56):
    (v->initially_active) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->initially_active), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->initially_active), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 57):
    (v->content_hook) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->content_hook), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->content_hook), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 58):
    (v->original_content) = (ContentBody*) Asn1Alloc (sizeof (ContentBody));
    CheckAsn1Alloc ((v->original_content), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecContentBodyContent (b, tagId2, elmtLen2, (v->original_content), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 59):
    (v->shared) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->shared), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->shared), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 70):
    (v->movement_table) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->movement_table), env);
    BDecTokenManagerClassSeqOfContent (b, tagId1, elmtLen1, (v->movement_table), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 71):
    (v->token_group_items) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->token_group_items), env);
    BDecTokenGroupClassSeqOfContent (b, tagId1, elmtLen1, (v->token_group_items), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 72):
    (v->no_token_action_slots) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->no_token_action_slots), env);
    BDecTokenGroupClassSeqOf1Content (b, tagId1, elmtLen1, (v->no_token_action_slots), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 73):
    (v->positions) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->positions), env);
    BDecListGroupClassSeqOfContent (b, tagId1, elmtLen1, (v->positions), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 74):
    (v->wrap_around) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->wrap_around), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->wrap_around), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 75):
    (v->multiple_selection) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->multiple_selection), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->multiple_selection), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecListGroupClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -678);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 2)
    {
        Asn1Error ("BDecListGroupClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -679);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecListGroupClassContent */




AsnLen
BEncGroupItemContent PARAMS ((b, v),
BUF_TYPE b _AND_
GroupItem *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case GROUPITEM_RESIDENT_PROGRAM:
    BEncEocIfNec (b);
    itemLen = BEncResidentProgramClassContent (b, (v->a.resident_program));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 9);

    totalLen += itemLen;

    break;

       case GROUPITEM_REMOTE_PROGRAM:
    BEncEocIfNec (b);
    itemLen = BEncRemoteProgramClassContent (b, (v->a.remote_program));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 10);

    totalLen += itemLen;

    break;

       case GROUPITEM_INTERCHANGED_PROGRAM:
    BEncEocIfNec (b);
    itemLen = BEncInterchangedProgramClassContent (b, (v->a.interchanged_program));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 11);

    totalLen += itemLen;

    break;

       case GROUPITEM_PALETTE:
    BEncEocIfNec (b);
    itemLen = BEncPaletteClassContent (b, (v->a.palette));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 12);

    totalLen += itemLen;

    break;

       case GROUPITEM_FONT:
    BEncEocIfNec (b);
    itemLen = BEncFontClassContent (b, (v->a.font_class));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 13);

    totalLen += itemLen;

    break;

       case GROUPITEM_CURSOR_SHAPE:
    BEncEocIfNec (b);
    itemLen = BEncCursorShapeClassContent (b, (v->a.cursor_shape));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 14);

    totalLen += itemLen;

    break;

       case GROUPITEM_BOOLEAN_VARIABLE:
    BEncEocIfNec (b);
    itemLen = BEncBooleanVariableClassContent (b, (v->a.boolean_variable));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 15);

    totalLen += itemLen;

    break;

       case GROUPITEM_INTEGER_VARIABLE:
    BEncEocIfNec (b);
    itemLen = BEncIntegerVariableClassContent (b, (v->a.integer_variable));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 16);

    totalLen += itemLen;

    break;

       case GROUPITEM_OCTET_STRING_VARIABLE:
    BEncEocIfNec (b);
    itemLen = BEncOctetStringVariableClassContent (b, (v->a.octet_string_variable));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 17);

    totalLen += itemLen;

    break;

       case GROUPITEM_OBJECT_REF_VARIABLE:
    BEncEocIfNec (b);
    itemLen = BEncObjectRefVariableClassContent (b, (v->a.object_ref_variable));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 18);

    totalLen += itemLen;

    break;

       case GROUPITEM_CONTENT_REF_VARIABLE:
    BEncEocIfNec (b);
    itemLen = BEncContentRefVariableClassContent (b, (v->a.content_ref_variable));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 19);

    totalLen += itemLen;

    break;

       case GROUPITEM_LINK:
    BEncEocIfNec (b);
    itemLen = BEncLinkClassContent (b, (v->a.link));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 20);

    totalLen += itemLen;

    break;

       case GROUPITEM_STREAM:
    BEncEocIfNec (b);
    itemLen = BEncStreamClassContent (b, (v->a.stream));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 21);

    totalLen += itemLen;

    break;

       case GROUPITEM_BITMAP:
    BEncEocIfNec (b);
    itemLen = BEncBitmapClassContent (b, (v->a.bitmap));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 22);

    totalLen += itemLen;

    break;

       case GROUPITEM_LINE_ART:
    BEncEocIfNec (b);
    itemLen = BEncLineArtClassContent (b, (v->a.line_art));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 23);

    totalLen += itemLen;

    break;

       case GROUPITEM_DYNAMIC_LINE_ART:
    BEncEocIfNec (b);
    itemLen = BEncDynamicLineArtClassContent (b, (v->a.dynamic_line_art));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 24);

    totalLen += itemLen;

    break;

       case GROUPITEM_RECTANGLE:
    BEncEocIfNec (b);
    itemLen = BEncRectangleClassContent (b, (v->a.rectangle));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 25);

    totalLen += itemLen;

    break;

       case GROUPITEM_HOTSPOT:
    BEncEocIfNec (b);
    itemLen = BEncHotspotClassContent (b, (v->a.hotspot));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 26);

    totalLen += itemLen;

    break;

       case GROUPITEM_SWITCH_BUTTON:
    BEncEocIfNec (b);
    itemLen = BEncSwitchButtonClassContent (b, (v->a.switch_button));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 27);

    totalLen += itemLen;

    break;

       case GROUPITEM_PUSH_BUTTON:
    BEncEocIfNec (b);
    itemLen = BEncPushButtonClassContent (b, (v->a.push_button));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 28);

    totalLen += itemLen;

    break;

       case GROUPITEM_TEXT:
    BEncEocIfNec (b);
    itemLen = BEncTextClassContent (b, (v->a.text));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 29);

    totalLen += itemLen;

    break;

       case GROUPITEM_ENTRY_FIELD:
    BEncEocIfNec (b);
    itemLen = BEncEntryFieldClassContent (b, (v->a.entry_field));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 30);

    totalLen += itemLen;

    break;

       case GROUPITEM_HYPER_TEXT:
    BEncEocIfNec (b);
    itemLen = BEncHyperTextClassContent (b, (v->a.hyper_text));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 31);

    totalLen += itemLen;

    break;

       case GROUPITEM_SLIDER:
    BEncEocIfNec (b);
    itemLen = BEncSliderClassContent (b, (v->a.slider));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 32);

    totalLen += itemLen;

    break;

       case GROUPITEM_TOKEN_GROUP:
    BEncEocIfNec (b);
    itemLen = BEncTokenGroupClassContent (b, (v->a.token_group));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 33);

    totalLen += itemLen;

    break;

       case GROUPITEM_LIST_GROUP:
    BEncEocIfNec (b);
    itemLen = BEncListGroupClassContent (b, (v->a.list_group));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 34);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncGroupItemContent */

void
BDecGroupItemContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GroupItem *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, CONS, 9):
        (v->choiceId) = GROUPITEM_RESIDENT_PROGRAM;
    (v->a.resident_program) = (ResidentProgramClass*) Asn1Alloc (sizeof (ResidentProgramClass));
    CheckAsn1Alloc ((v->a.resident_program), env);
    BDecResidentProgramClassContent (b, tagId0, elmtLen0, (v->a.resident_program), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 10):
        (v->choiceId) = GROUPITEM_REMOTE_PROGRAM;
    (v->a.remote_program) = (RemoteProgramClass*) Asn1Alloc (sizeof (RemoteProgramClass));
    CheckAsn1Alloc ((v->a.remote_program), env);
    BDecRemoteProgramClassContent (b, tagId0, elmtLen0, (v->a.remote_program), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 11):
        (v->choiceId) = GROUPITEM_INTERCHANGED_PROGRAM;
    (v->a.interchanged_program) = (InterchangedProgramClass*) Asn1Alloc (sizeof (InterchangedProgramClass));
    CheckAsn1Alloc ((v->a.interchanged_program), env);
    BDecInterchangedProgramClassContent (b, tagId0, elmtLen0, (v->a.interchanged_program), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 12):
        (v->choiceId) = GROUPITEM_PALETTE;
    (v->a.palette) = (PaletteClass*) Asn1Alloc (sizeof (PaletteClass));
    CheckAsn1Alloc ((v->a.palette), env);
    BDecPaletteClassContent (b, tagId0, elmtLen0, (v->a.palette), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 13):
        (v->choiceId) = GROUPITEM_FONT;
    (v->a.font_class) = (FontClass*) Asn1Alloc (sizeof (FontClass));
    CheckAsn1Alloc ((v->a.font_class), env);
    BDecFontClassContent (b, tagId0, elmtLen0, (v->a.font_class), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 14):
        (v->choiceId) = GROUPITEM_CURSOR_SHAPE;
    (v->a.cursor_shape) = (CursorShapeClass*) Asn1Alloc (sizeof (CursorShapeClass));
    CheckAsn1Alloc ((v->a.cursor_shape), env);
    BDecCursorShapeClassContent (b, tagId0, elmtLen0, (v->a.cursor_shape), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 15):
        (v->choiceId) = GROUPITEM_BOOLEAN_VARIABLE;
    (v->a.boolean_variable) = (BooleanVariableClass*) Asn1Alloc (sizeof (BooleanVariableClass));
    CheckAsn1Alloc ((v->a.boolean_variable), env);
    BDecBooleanVariableClassContent (b, tagId0, elmtLen0, (v->a.boolean_variable), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 16):
        (v->choiceId) = GROUPITEM_INTEGER_VARIABLE;
    (v->a.integer_variable) = (IntegerVariableClass*) Asn1Alloc (sizeof (IntegerVariableClass));
    CheckAsn1Alloc ((v->a.integer_variable), env);
    BDecIntegerVariableClassContent (b, tagId0, elmtLen0, (v->a.integer_variable), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 17):
        (v->choiceId) = GROUPITEM_OCTET_STRING_VARIABLE;
    (v->a.octet_string_variable) = (OctetStringVariableClass*) Asn1Alloc (sizeof (OctetStringVariableClass));
    CheckAsn1Alloc ((v->a.octet_string_variable), env);
    BDecOctetStringVariableClassContent (b, tagId0, elmtLen0, (v->a.octet_string_variable), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 18):
        (v->choiceId) = GROUPITEM_OBJECT_REF_VARIABLE;
    (v->a.object_ref_variable) = (ObjectRefVariableClass*) Asn1Alloc (sizeof (ObjectRefVariableClass));
    CheckAsn1Alloc ((v->a.object_ref_variable), env);
    BDecObjectRefVariableClassContent (b, tagId0, elmtLen0, (v->a.object_ref_variable), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 19):
        (v->choiceId) = GROUPITEM_CONTENT_REF_VARIABLE;
    (v->a.content_ref_variable) = (ContentRefVariableClass*) Asn1Alloc (sizeof (ContentRefVariableClass));
    CheckAsn1Alloc ((v->a.content_ref_variable), env);
    BDecContentRefVariableClassContent (b, tagId0, elmtLen0, (v->a.content_ref_variable), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 20):
        (v->choiceId) = GROUPITEM_LINK;
    (v->a.link) = (LinkClass*) Asn1Alloc (sizeof (LinkClass));
    CheckAsn1Alloc ((v->a.link), env);
    BDecLinkClassContent (b, tagId0, elmtLen0, (v->a.link), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 21):
        (v->choiceId) = GROUPITEM_STREAM;
    (v->a.stream) = (StreamClass*) Asn1Alloc (sizeof (StreamClass));
    CheckAsn1Alloc ((v->a.stream), env);
    BDecStreamClassContent (b, tagId0, elmtLen0, (v->a.stream), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 22):
        (v->choiceId) = GROUPITEM_BITMAP;
    (v->a.bitmap) = (BitmapClass*) Asn1Alloc (sizeof (BitmapClass));
    CheckAsn1Alloc ((v->a.bitmap), env);
    BDecBitmapClassContent (b, tagId0, elmtLen0, (v->a.bitmap), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 23):
        (v->choiceId) = GROUPITEM_LINE_ART;
    (v->a.line_art) = (LineArtClass*) Asn1Alloc (sizeof (LineArtClass));
    CheckAsn1Alloc ((v->a.line_art), env);
    BDecLineArtClassContent (b, tagId0, elmtLen0, (v->a.line_art), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 24):
        (v->choiceId) = GROUPITEM_DYNAMIC_LINE_ART;
    (v->a.dynamic_line_art) = (DynamicLineArtClass*) Asn1Alloc (sizeof (DynamicLineArtClass));
    CheckAsn1Alloc ((v->a.dynamic_line_art), env);
    BDecDynamicLineArtClassContent (b, tagId0, elmtLen0, (v->a.dynamic_line_art), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 25):
        (v->choiceId) = GROUPITEM_RECTANGLE;
    (v->a.rectangle) = (RectangleClass*) Asn1Alloc (sizeof (RectangleClass));
    CheckAsn1Alloc ((v->a.rectangle), env);
    BDecRectangleClassContent (b, tagId0, elmtLen0, (v->a.rectangle), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 26):
        (v->choiceId) = GROUPITEM_HOTSPOT;
    (v->a.hotspot) = (HotspotClass*) Asn1Alloc (sizeof (HotspotClass));
    CheckAsn1Alloc ((v->a.hotspot), env);
    BDecHotspotClassContent (b, tagId0, elmtLen0, (v->a.hotspot), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 27):
        (v->choiceId) = GROUPITEM_SWITCH_BUTTON;
    (v->a.switch_button) = (SwitchButtonClass*) Asn1Alloc (sizeof (SwitchButtonClass));
    CheckAsn1Alloc ((v->a.switch_button), env);
    BDecSwitchButtonClassContent (b, tagId0, elmtLen0, (v->a.switch_button), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 28):
        (v->choiceId) = GROUPITEM_PUSH_BUTTON;
    (v->a.push_button) = (PushButtonClass*) Asn1Alloc (sizeof (PushButtonClass));
    CheckAsn1Alloc ((v->a.push_button), env);
    BDecPushButtonClassContent (b, tagId0, elmtLen0, (v->a.push_button), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 29):
        (v->choiceId) = GROUPITEM_TEXT;
    (v->a.text) = (TextClass*) Asn1Alloc (sizeof (TextClass));
    CheckAsn1Alloc ((v->a.text), env);
    BDecTextClassContent (b, tagId0, elmtLen0, (v->a.text), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 30):
        (v->choiceId) = GROUPITEM_ENTRY_FIELD;
    (v->a.entry_field) = (EntryFieldClass*) Asn1Alloc (sizeof (EntryFieldClass));
    CheckAsn1Alloc ((v->a.entry_field), env);
    BDecEntryFieldClassContent (b, tagId0, elmtLen0, (v->a.entry_field), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 31):
        (v->choiceId) = GROUPITEM_HYPER_TEXT;
    (v->a.hyper_text) = (HyperTextClass*) Asn1Alloc (sizeof (HyperTextClass));
    CheckAsn1Alloc ((v->a.hyper_text), env);
    BDecHyperTextClassContent (b, tagId0, elmtLen0, (v->a.hyper_text), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 32):
        (v->choiceId) = GROUPITEM_SLIDER;
    (v->a.slider) = (SliderClass*) Asn1Alloc (sizeof (SliderClass));
    CheckAsn1Alloc ((v->a.slider), env);
    BDecSliderClassContent (b, tagId0, elmtLen0, (v->a.slider), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 33):
        (v->choiceId) = GROUPITEM_TOKEN_GROUP;
    (v->a.token_group) = (TokenGroupClass*) Asn1Alloc (sizeof (TokenGroupClass));
    CheckAsn1Alloc ((v->a.token_group), env);
    BDecTokenGroupClassContent (b, tagId0, elmtLen0, (v->a.token_group), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 34):
        (v->choiceId) = GROUPITEM_LIST_GROUP;
    (v->a.list_group) = (ListGroupClass*) Asn1Alloc (sizeof (ListGroupClass));
    CheckAsn1Alloc ((v->a.list_group), env);
    BDecListGroupClassContent (b, tagId0, elmtLen0, (v->a.list_group), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -680);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGroupItemContent */




AsnLen
BEncGroupClassSeqOfContent PARAMS ((b, v),
BUF_TYPE b _AND_
GroupClassSeqOf *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

        listLen = 0;
    FOR_EACH_LIST_ELMT_RVS (component, v)
    {
    itemLen = BEncGroupItemContent (b, component);

        listLen += itemLen;
    }
    return listLen;

}  /* BEncGroupClassSeqOfContent */

void
BDecGroupClassSeqOfContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GroupClassSeqOf *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    for (totalElmtsLen1 = 0; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
    {
        GroupItem **tmpVar;
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET OF/SEQ OF's for loop*/
    }
        elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    tmpVar = (GroupItem**) AsnListAppend (v);
    (*tmpVar) = (GroupItem*) Asn1Alloc (sizeof (GroupItem));
    CheckAsn1Alloc ((*tmpVar), env);
    BDecGroupItemContent (b, tagId1, elmtLen1, (*tmpVar), &totalElmtsLen1, env);
    } /* end of for */

    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGroupClassSeqOfContent */




AsnLen
BEncGroupClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
GroupClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->items)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGroupClassSeqOfContent (b, (v->items));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 8);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_group_cache_priority)))
    {
    itemLen = BEncAsnIntContent (b, (v->original_group_cache_priority));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, CNTX, PRIM, 7);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->on_close_down)))
    {
    BEncEocIfNec (b);
    itemLen = BEncActionClassContent (b, (v->on_close_down));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 6);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->on_start_up)))
    {
    BEncEocIfNec (b);
    itemLen = BEncActionClassContent (b, (v->on_start_up));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 5);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->object_information)))
    {
    itemLen = BEncAsnOctsContent (b, (&v->object_information));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, PRIM, 4);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->standard_version)))
    {
    itemLen = BEncAsnIntContent (b, (v->standard_version));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, CNTX, PRIM, 3);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->standard_identifier)))
    {
    BEncEocIfNec (b);
    itemLen = BEncStandardIdentifierContent (b, (v->standard_identifier));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 2);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncGroupClassContent */

void
BDecGroupClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
GroupClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 2):
    (v->standard_identifier) = (StandardIdentifier*) Asn1Alloc (sizeof (StandardIdentifier));
    CheckAsn1Alloc ((v->standard_identifier), env);
    BDecStandardIdentifierContent (b, tagId1, elmtLen1, (v->standard_identifier), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 3):
    (v->standard_version) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->standard_version), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->standard_version), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 4):
       case MAKE_TAG_ID (CNTX, PRIM, 4):
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->object_information), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 5):
    (v->on_start_up) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->on_start_up), env);
    BDecActionClassContent (b, tagId1, elmtLen1, (v->on_start_up), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 6):
    (v->on_close_down) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->on_close_down), env);
    BDecActionClassContent (b, tagId1, elmtLen1, (v->on_close_down), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 7):
    (v->original_group_cache_priority) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->original_group_cache_priority), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->original_group_cache_priority), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 8):
    (v->items) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->items), env);
    BDecGroupClassSeqOfContent (b, tagId1, elmtLen1, (v->items), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecGroupClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -681);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 1)
    {
        Asn1Error ("BDecGroupClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -682);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecGroupClassContent */




AsnLen
BEncApplicationClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
ApplicationClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->original_desktop_colour)))
    {
    BEncEocIfNec (b);
    itemLen = BEncColourContent (b, (v->original_desktop_colour));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag3 (b, CNTX, CONS, 249);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->default_attributes)))
    {
    BEncEocIfNec (b);
    itemLen = BEncApplicationClassSeqOfContent (b, (v->default_attributes));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 37);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->on_restart)))
    {
    BEncEocIfNec (b);
    itemLen = BEncActionClassContent (b, (v->on_restart));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 36);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->on_spawn_close_down)))
    {
    BEncEocIfNec (b);
    itemLen = BEncActionClassContent (b, (v->on_spawn_close_down));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 35);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->items)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGroupClassSeqOfContent (b, (v->items));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 8);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_group_cache_priority)))
    {
    itemLen = BEncAsnIntContent (b, (v->original_group_cache_priority));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, CNTX, PRIM, 7);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->on_close_down)))
    {
    BEncEocIfNec (b);
    itemLen = BEncActionClassContent (b, (v->on_close_down));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 6);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->on_start_up)))
    {
    BEncEocIfNec (b);
    itemLen = BEncActionClassContent (b, (v->on_start_up));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 5);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->object_information)))
    {
    itemLen = BEncAsnOctsContent (b, (&v->object_information));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, PRIM, 4);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->standard_version)))
    {
    itemLen = BEncAsnIntContent (b, (v->standard_version));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, CNTX, PRIM, 3);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->standard_identifier)))
    {
    BEncEocIfNec (b);
    itemLen = BEncStandardIdentifierContent (b, (v->standard_identifier));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 2);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncApplicationClassContent */

void
BDecApplicationClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
ApplicationClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;
    AsnLen totalElmtsLen3 = 0;
    AsnLen elmtLen3;
    AsnTag tagId3;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 2):
    (v->standard_identifier) = (StandardIdentifier*) Asn1Alloc (sizeof (StandardIdentifier));
    CheckAsn1Alloc ((v->standard_identifier), env);
    BDecStandardIdentifierContent (b, tagId1, elmtLen1, (v->standard_identifier), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 3):
    (v->standard_version) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->standard_version), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->standard_version), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 4):
       case MAKE_TAG_ID (CNTX, PRIM, 4):
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->object_information), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 5):
    (v->on_start_up) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->on_start_up), env);
    BDecActionClassContent (b, tagId1, elmtLen1, (v->on_start_up), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 6):
    (v->on_close_down) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->on_close_down), env);
    BDecActionClassContent (b, tagId1, elmtLen1, (v->on_close_down), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 7):
    (v->original_group_cache_priority) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->original_group_cache_priority), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->original_group_cache_priority), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 8):
    (v->items) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->items), env);
    BDecGroupClassSeqOfContent (b, tagId1, elmtLen1, (v->items), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 35):
    (v->on_spawn_close_down) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->on_spawn_close_down), env);
    BDecActionClassContent (b, tagId1, elmtLen1, (v->on_spawn_close_down), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 36):
    (v->on_restart) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->on_restart), env);
    BDecActionClassContent (b, tagId1, elmtLen1, (v->on_restart), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 37):
    (v->default_attributes) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->default_attributes), env);
    BDecApplicationClassSeqOfContent (b, tagId1, elmtLen1, (v->default_attributes), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 249):
    (v->original_desktop_colour) = (Colour*) Asn1Alloc (sizeof (Colour));
    CheckAsn1Alloc ((v->original_desktop_colour), env);
    tagId2 = BDecTag (b, &totalElmtsLen1, env);
    elmtLen2 = BDecLen (b, &totalElmtsLen1, env);
    BDecColourContent (b, tagId2, elmtLen2, (v->original_desktop_colour), &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc(b, &totalElmtsLen1, env);
    if (elmtLen1 == INDEFINITE_LEN)
        BDecEoc (b, &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecApplicationClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -683);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 1)
    {
        Asn1Error ("BDecApplicationClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -684);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecApplicationClassContent */




AsnLen
BEncSceneClassContent PARAMS ((b, v),
BUF_TYPE b _AND_
SceneClass *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    if (NOT_NULL ((v->next_scenes)))
    {
    BEncEocIfNec (b);
    itemLen = BEncSceneClassSeqOfContent (b, (v->next_scenes));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 55);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->moving_cursor)))
    {
    itemLen = BEncAsnBoolContent (b, (v->moving_cursor));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 54);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->aspect_ratio)))
    {
    BEncEocIfNec (b);
    itemLen = BEncAspectRatioContent (b, (v->aspect_ratio));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 53);

    totalLen += itemLen;
    }

    BEncEocIfNec (b);
    itemLen = BEncSceneCoordinateSystemContent (b, (v->scene_coordinate_system));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag2 (b, CNTX, CONS, 52);

    totalLen += itemLen;

    itemLen = BEncAsnIntContent (b, (&v->input_event_register));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag2 (b, CNTX, PRIM, 51);

    totalLen += itemLen;

    if (NOT_NULL ((v->items)))
    {
    BEncEocIfNec (b);
    itemLen = BEncGroupClassSeqOfContent (b, (v->items));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 8);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->original_group_cache_priority)))
    {
    itemLen = BEncAsnIntContent (b, (v->original_group_cache_priority));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, CNTX, PRIM, 7);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->on_close_down)))
    {
    BEncEocIfNec (b);
    itemLen = BEncActionClassContent (b, (v->on_close_down));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 6);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->on_start_up)))
    {
    BEncEocIfNec (b);
    itemLen = BEncActionClassContent (b, (v->on_start_up));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 5);

    totalLen += itemLen;
    }

    if (ASNOCTS_PRESENT ((&v->object_information)))
    {
    itemLen = BEncAsnOctsContent (b, (&v->object_information));
    itemLen += BEncDefLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, PRIM, 4);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->standard_version)))
    {
    itemLen = BEncAsnIntContent (b, (v->standard_version));
    BEncDefLenTo127 (b, itemLen);
    itemLen++;
    itemLen += BEncTag1 (b, CNTX, PRIM, 3);

    totalLen += itemLen;
    }

    if (NOT_NULL ((v->standard_identifier)))
    {
    BEncEocIfNec (b);
    itemLen = BEncStandardIdentifierContent (b, (v->standard_identifier));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 2);

    totalLen += itemLen;
    }

    itemLen = BEncRootClassContent (b, (v->rootClass));

    totalLen += itemLen;

    return totalLen;

}  /* BEncSceneClassContent */

void
BDecSceneClassContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
SceneClass *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;
    AsnLen totalElmtsLen2 = 0;
    AsnLen elmtLen2;
    AsnTag tagId2;


for ( ; (totalElmtsLen1 < elmtLen0) || (elmtLen0 == INDEFINITE_LEN);)
{
    tagId1 = BDecTag (b, &totalElmtsLen1, env);

    if ((tagId1 == EOC_TAG_ID) && (elmtLen0 == INDEFINITE_LEN))
    {
        BDEC_2ND_EOC_OCTET (b, &totalElmtsLen1, env)
        break; /* got EOC so can exit this SET's for loop*/
    }
    elmtLen1 = BDecLen (b, &totalElmtsLen1, env);
    switch (tagId1)
    {
       case MAKE_TAG_ID (UNIV, CONS, SEQ_TAG_CODE):
       case MAKE_TAG_ID (UNIV, PRIM, INTEGER_TAG_CODE):
    (v->rootClass) = (RootClass*) Asn1Alloc (sizeof (RootClass));
    CheckAsn1Alloc ((v->rootClass), env);
    BDecRootClassContent (b, tagId1, elmtLen1, (v->rootClass), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 2):
    (v->standard_identifier) = (StandardIdentifier*) Asn1Alloc (sizeof (StandardIdentifier));
    CheckAsn1Alloc ((v->standard_identifier), env);
    BDecStandardIdentifierContent (b, tagId1, elmtLen1, (v->standard_identifier), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 3):
    (v->standard_version) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->standard_version), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->standard_version), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 4):
       case MAKE_TAG_ID (CNTX, PRIM, 4):
    BDecAsnOctsContent (b, tagId1, elmtLen1, (&v->object_information), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 5):
    (v->on_start_up) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->on_start_up), env);
    BDecActionClassContent (b, tagId1, elmtLen1, (v->on_start_up), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 6):
    (v->on_close_down) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->on_close_down), env);
    BDecActionClassContent (b, tagId1, elmtLen1, (v->on_close_down), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 7):
    (v->original_group_cache_priority) = (AsnInt*) Asn1Alloc (sizeof (AsnInt));
    CheckAsn1Alloc ((v->original_group_cache_priority), env);
    BDecAsnIntContent (b, tagId1, elmtLen1, (v->original_group_cache_priority), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 8):
    (v->items) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->items), env);
    BDecGroupClassSeqOfContent (b, tagId1, elmtLen1, (v->items), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 51):
    BDecAsnIntContent (b, tagId1, elmtLen1, (&v->input_event_register), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 52):
    (v->scene_coordinate_system) = (SceneCoordinateSystem*) Asn1Alloc (sizeof (SceneCoordinateSystem));
    CheckAsn1Alloc ((v->scene_coordinate_system), env);
    BDecSceneCoordinateSystemContent (b, tagId1, elmtLen1, (v->scene_coordinate_system), &totalElmtsLen1, env);
    mandatoryElmtCount1++;
    break;

       case MAKE_TAG_ID (CNTX, CONS, 53):
    (v->aspect_ratio) = (AspectRatio*) Asn1Alloc (sizeof (AspectRatio));
    CheckAsn1Alloc ((v->aspect_ratio), env);
    BDecAspectRatioContent (b, tagId1, elmtLen1, (v->aspect_ratio), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, PRIM, 54):
    (v->moving_cursor) = (AsnBool*) Asn1Alloc (sizeof (AsnBool));
    CheckAsn1Alloc ((v->moving_cursor), env);
    BDecAsnBoolContent (b, tagId1, elmtLen1, (v->moving_cursor), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 55):
    (v->next_scenes) = AsnListNew (sizeof (char*));
    CheckAsn1Alloc ((v->next_scenes), env);
    BDecSceneClassSeqOfContent (b, tagId1, elmtLen1, (v->next_scenes), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("BDecSceneClassContent: ERROR - Unexpected tag in SET\n");
        longjmp (env, -685);
        break;
        } /* end switch */
    } /* end for */
    if (mandatoryElmtCount1 != 3)
    {
        Asn1Error ("BDecSceneClassContent: ERROR - non-optional elmt missing from SET\n");
        longjmp (env, -686);
    }
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecSceneClassContent */




AsnLen
BEncInterchangedObjectContent PARAMS ((b, v),
BUF_TYPE b _AND_
InterchangedObject *v)
{
    AsnLen totalLen = 0;
    AsnLen itemLen;
    AsnLen listLen;
    void *component;

    switch (v->choiceId)
    {
       case INTERCHANGEDOBJECT_APPLICATION:
    BEncEocIfNec (b);
    itemLen = BEncApplicationClassContent (b, (v->a.application));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 0);

    totalLen += itemLen;

    break;

       case INTERCHANGEDOBJECT_SCENE:
    BEncEocIfNec (b);
    itemLen = BEncSceneClassContent (b, (v->a.scene));
    itemLen += BEncConsLen (b, itemLen);
    itemLen += BEncTag1 (b, CNTX, CONS, 1);

    totalLen += itemLen;

    break;

    }
    return totalLen;

}  /* BEncInterchangedObjectContent */

void
BDecInterchangedObjectContent PARAMS ((b, tagId0, elmtLen0, v, bytesDecoded, env),
BUF_TYPE b _AND_
AsnTag tagId0 _AND_
AsnLen elmtLen0 _AND_
InterchangedObject *v _AND_
AsnLen *bytesDecoded _AND_
ENV_TYPE env)
{
    int seqDone = FALSE;
    AsnLen totalElmtsLen1 = 0;
    AsnLen elmtLen1;
    AsnTag tagId1;
    int mandatoryElmtCount1 = 0;


    switch (tagId0)
    {
       case MAKE_TAG_ID (CNTX, CONS, 0):
        (v->choiceId) = INTERCHANGEDOBJECT_APPLICATION;
    (v->a.application) = (ApplicationClass*) Asn1Alloc (sizeof (ApplicationClass));
    CheckAsn1Alloc ((v->a.application), env);
    BDecApplicationClassContent (b, tagId0, elmtLen0, (v->a.application), &totalElmtsLen1, env);
    break;

       case MAKE_TAG_ID (CNTX, CONS, 1):
        (v->choiceId) = INTERCHANGEDOBJECT_SCENE;
    (v->a.scene) = (SceneClass*) Asn1Alloc (sizeof (SceneClass));
    CheckAsn1Alloc ((v->a.scene), env);
    BDecSceneClassContent (b, tagId0, elmtLen0, (v->a.scene), &totalElmtsLen1, env);
    break;

    default:
        Asn1Error ("ERROR - unexpected tag in CHOICE\n");
        longjmp (env, -687);
        break;
    } /* end switch */
    (*bytesDecoded) += totalElmtsLen1;
}  /* BDecInterchangedObjectContent */



/*
 * Local variables:
 * mode: c
 * compile-command: "make -C ../"
 *  c-indent-level: 4
 *  c-basic-offset: 4
 *  tab-width: 4
 * End:
 */
